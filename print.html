<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Doc ENAC Robotique</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="accueil.html"><strong aria-hidden="true">1.</strong> Accueil</a></li><li class="chapter-item expanded "><a href="organisation/orga.html"><strong aria-hidden="true">2.</strong> Organisation du club</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="organisation/activites.html"><strong aria-hidden="true">2.1.</strong> Activitées</a></li><li class="chapter-item expanded "><a href="organisation/membre.html"><strong aria-hidden="true">2.2.</strong> Être membre du club</a></li><li class="chapter-item expanded "><a href="organisation/logistique.html"><strong aria-hidden="true">2.3.</strong> Logistique</a></li><li class="chapter-item expanded "><a href="organisation/contacts.html"><strong aria-hidden="true">2.4.</strong> Contacts</a></li></ol></li><li class="chapter-item expanded "><a href="introductions/introRobot.html"><strong aria-hidden="true">3.</strong> Intro Création robot</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introductions/lexique.html"><strong aria-hidden="true">3.1.</strong> Lexique</a></li><li class="chapter-item expanded "><a href="datasheets/datasheets.html"><strong aria-hidden="true">3.2.</strong> Datasheets</a></li></ol></li><li class="chapter-item expanded "><a href="bases/index.html"><strong aria-hidden="true">4.</strong> Les bases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bases/info/index.html"><strong aria-hidden="true">4.1.</strong> Programmation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bases/info/vscode.html"><strong aria-hidden="true">4.1.1.</strong> VS Code & Platformio</a></li><li class="chapter-item expanded "><a href="bases/info/introPython.html"><strong aria-hidden="true">4.1.2.</strong> Python</a></li><li class="chapter-item expanded "><a href="bases/info/introC.html"><strong aria-hidden="true">4.1.3.</strong> Progammation pour l'embarqué </a></li></ol></li><li class="chapter-item expanded "><a href="bases/meca/introMeca.html"><strong aria-hidden="true">4.2.</strong> Mécanique</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bases/meca/onshape.html"><strong aria-hidden="true">4.2.1.</strong> Onshape</a></li><li class="chapter-item expanded "><a href="bases/meca/imprimante.html"><strong aria-hidden="true">4.2.2.</strong> Impression3D</a></li><li class="chapter-item expanded "><a href="bases/meca/laser.html"><strong aria-hidden="true">4.2.3.</strong> Découpe Laser</a></li></ol></li><li class="chapter-item expanded "><a href="bases/elec/index.html"><strong aria-hidden="true">4.3.</strong> Électronique</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bases/elec/led.html"><strong aria-hidden="true">4.3.1.</strong> Allumer une Led</a></li><li class="chapter-item expanded "><a href="bases/elec/sos_elec.html"><strong aria-hidden="true">4.3.2.</strong> Identifier un problème dans un circuit</a></li><li class="chapter-item expanded "><a href="bases/elec/microcontroleur.html"><strong aria-hidden="true">4.3.3.</strong> Microcontrôleurs</a></li><li class="chapter-item expanded "><a href="bases/elec/kicad.html"><strong aria-hidden="true">4.3.4.</strong> Kicad</a></li></ol></li><li class="chapter-item expanded "><a href="bases/linux/index.html"><strong aria-hidden="true">4.4.</strong> Linux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bases/linux/dual_boot.html"><strong aria-hidden="true">4.4.1.</strong> Dual Boot</a></li><li class="chapter-item expanded "><a href="bases/linux/git.html"><strong aria-hidden="true">4.4.2.</strong> Git</a></li><li class="chapter-item expanded "><a href="bases/linux/ssh.html"><strong aria-hidden="true">4.4.3.</strong> SSH</a></li><li class="chapter-item expanded "><a href="bases/linux/bash_usefull.html"><strong aria-hidden="true">4.4.4.</strong> Bash tips</a></li></ol></li><li class="chapter-item expanded "><a href="bases/tutoboard/tutoboard.html"><strong aria-hidden="true">4.5.</strong> La tutoboard Enac</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bases/tutoboard/bases.html"><strong aria-hidden="true">4.5.1.</strong> Les bases</a></li><li class="chapter-item expanded "><a href="bases/tutoboard/comm.html"><strong aria-hidden="true">4.5.2.</strong> La communications</a></li><li class="chapter-item expanded "><a href="bases/tutoboard/attiny.html"><strong aria-hidden="true">4.5.3.</strong> L'Attiny</a></li></ol></li><li class="chapter-item expanded "><a href="bases/tutopami/index.html"><strong aria-hidden="true">4.6.</strong> Tuto Pami</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bases/tutopami/freertos.html"><strong aria-hidden="true">4.6.1.</strong> FreeRTOS</a></li><li class="chapter-item expanded "><a href="bases/tutopami/tuto.html"><strong aria-hidden="true">4.6.2.</strong> Programmer un PAMI</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="to_robot/to_robot.html"><strong aria-hidden="true">5.</strong> Vers le robot (WIP)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="to_robot/base_roulante/holonome.html"><strong aria-hidden="true">5.1.</strong> Base roulante Holonome</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.1.</strong> Conception Méca</div></li><li class="chapter-item expanded "><a href="to_robot/base_roulante/carte_elec.html"><strong aria-hidden="true">5.1.2.</strong> Conception éléc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="to_robot/base_roulante/carte2024.html"><strong aria-hidden="true">5.1.2.1.</strong> Carte 2024</a></li><li class="chapter-item expanded "><a href="to_robot/base_roulante/notions_elec.html"><strong aria-hidden="true">5.1.2.2.</strong> Notions pour la conception éléc</a></li></ol></li><li class="chapter-item expanded "><a href="to_robot/commande/asserv.html"><strong aria-hidden="true">5.1.3.</strong> Commande</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Les actionneurs</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.1.</strong> Prototypage</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.2.</strong> Intégration</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Communications</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.1.</strong> Comm Haut/Bas niveau</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.2.</strong> eCal et protobuff</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> Le haut niveau</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="to_robot/haut_niveau/raspberry_pi.html"><strong aria-hidden="true">5.4.1.</strong> Monter une raspi</a></li><li class="chapter-item expanded "><a href="to_robot/haut_niveau/interface.html"><strong aria-hidden="true">5.4.2.</strong> Interfaçage</a></li><li class="chapter-item expanded "><a href="to_robot/haut_niveau/decision.html"><strong aria-hidden="true">5.4.3.</strong> Inteligence du robot</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> FAQ/REX : Retour D'expérience</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="rex/shoot.html"><strong aria-hidden="true">6.1.</strong> Système de tir</a></li></ol></li><li class="chapter-item expanded "><a href="petits_tutos/index.html"><strong aria-hidden="true">7.</strong> Petits tutos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="petits_tutos/peripherique_occupe.html"><strong aria-hidden="true">7.1.</strong> Périphérique occupé au branchement d'un µC</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Doc ENAC Robotique</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- 
<p align="center">
<img src="images/logo_IA.jpg"  alt="image" width="350" height="auto">
</p> -->
<p><img src="images/enac_robotique_logo.png" alt="" title="Bienvenu à l&#39;ENAC Robotique !" /></p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Ce site contient la documentation du club robot de l'ENAC. Il est en cours de construction, donc très incomplet pour l'instant. Il est écrit et maintenu par des élèves amateurs de la robotique. N'hésite pas à <a href="https://github.com/ENACRobotique/doc">contribuer</a> !</p>
<p>Si vous êtes <strong>nouveau</strong>, lisez jusqu'à la section 4 (inclus) pour des tutoriels intéressants à suivre, et posez vos questions sur le <a href="https://discord.com/invite/7sPZFxb">Discord</a> !</p>
<p>Si vous voulez <strong>utiliser le matériel du club</strong>, c'est possible mais attention nous ne sommes <strong>pas</strong> un FabLab. Venez nous voir le Jeudi après midi ou contactez nous sur <a href="organisation/contacts.html">nos réseaux</a>.</p>
<p>On conseille au cours de l'année de lire les <strong><a href="rex/asserv.html">Retour d'Experience (REX)</a></strong> que ce soit sur la conception des robots en début d'année puis sur la coupe pour ne pas répéter les erreurs.</p>
<p>Ensuite, si vous avez besoin de tutos spécifiques sur certains sujets ou des clés pour se lancer, il faut consulter les <a href="petits_tutos/index.html">petits tutos</a></p>
<p>Cette documentation est un outil pour orienter l'apprentissage de la robotique et ne se suffit pas à elle-même. Il s'agit souvent de redirection vers des ressources utiles pour faciliter la recherche aux novices. Nous ne prétendons pas donner des standards de la création d'un robot car il existe beaucoup de méthodes et de concepts liées. Nous nous reposons ici sur notre expérience</p>
<p><strong>Dernière mise à jour : Juillet 2024</strong>
Changements:</p>
<ul>
<li>Section 4</li>
<li>Section 5</li>
</ul>
<!-- Pour les programmeurs, consulter Tuto Code pour comprendre le principe. -->
<!-- Voici l'ordre de "lecture" du site :  -->
<!-- ![](images/Accueil.png) -->
<div style="break-before: page; page-break-before: always;"></div><h2 id="ou-est-le-club-"><a class="header" href="#ou-est-le-club-">Ou est le club ?</a></h2>
<p>Le club se situe dans le bâtiment Z-008 <strong>en face de la volière drone</strong>.</p>
<p>L'accès y est règlementé, il faut un droit d'accès. Vous devrez donc passer par un membre du club pour y entrer en tant que visiteur ou en attendant d'avoir vos propres accès.</p>
<p><img src="organisation/../images/carte.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="activitée-principale"><a class="header" href="#activitée-principale">Activitée Principale</a></h1>
<div style="display: flex; align-items: flex-start;">
<a href="https://www.coupederobotique.fr/" >
<img src="organisation/../images/cdfr_logo.png" width="1500px"> </a>
<div style="padding-left: 30px;">
<p>Chaque année, nous participons à la <a href="https://www.coupederobotique.fr/">Coupe de france de robotique</a>, organisée par Planète Sciences. Cette compétition rassemble tous les ans plus d’une centaine d’équipes venus de toute la France, et même du monde pour la coupe d’Europe <a href="https://www.eurobot.org/">Eurobot</a> qui s’y déroule en même temps. L'évènement se tiens à la <a href="https://maps.app.goo.gl/Hom6DXjm2Rnr7Usx8">Roche sur Yon</a>.
Les participants regroupent des étudiants venus d’écoles d’ingénieurs tels que nous, mais aussi d’IUT et des anciens étudiants désireux de participer à nouveau.</p>
</div>
</div>
<p>Les matchs se déroulent sur une table de 2*3m pendant 100s, contre une autre équipe. Le principe est qu'il y à plusieurs interactions possibles définies par un thème annuel. Chaque action rapporte un certain nombre de points, le but étant de faire le score le plus élevé possible. Tous les robots doivent être autonomes. Cela implique qu’ils doivent disposer de différents capteurs afin de se repérer et repérer les éléments de jeu sur la table.</p>
<img src="organisation/../images/cdfr.jpeg" height="auto" width="800px">
<p>Il est possible aussi de rejoindre le <a href="https://discord.gg/tteC3Cp">Discord</a> officiel de la coupe. On peut y discuter avec les organisateur et toutes les équipes. Parfait pour obtenir du support et des retours d'expériences.</p>
<p>L'évènemet est aussi parfait pour rencontrer des entreprises commes ST, Exotec, Continental ect... qui sponsorisent l'évènement et y tiennent des stands. Si vous cherchez un stage ou un emploi par exemple.</p>
<img src="organisation/../images/exotec.png" >
<p>On peux y remporter plusieurs prix basés sur certaines performances des équipes  ( créativité, communications, organisation ...). Néanmoins il n'y a pas de prix matériel. La vraie récompense est l'aventure vécue, l'expérience, les compétences et les personnes rencontrées.</p>
<p><img src="organisation/../images/prix.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Être-membre-du-club"><a class="header" href="#Être-membre-du-club">Être membre du club</a></h2>
<p>Pour faire partie du club, il faut :</p>
<ol>
<li>
<p>Être sur le <strong><a href="https://discord.com/invite/7sPZFxb">Discord</a></strong>, c'est le point central de nos communications internes !</p>
</li>
<li>
<p>Remplir ses <strong>coordonnées</strong> sur le <a href="https://docs.google.com/forms/d/e/1FAIpQLSdatJGEQBnEPTqi0qsnMXBmfnNNL4iHKDigHQGw1pEdLLsQVQ/viewform?usp=sf_link">Google form</a>.</p>
</li>
<li>
<p>Ensuite, il est impératif de <strong>participer</strong> à la réunion hebdomadaire du <strong>jeudi</strong> (ou de consulter le Compte-rendu si vous ne pouvez pas venir certaines fois).</p>
</li>
<li>
<p>Enfin, il ne faut <strong>pas hésiter à demander</strong> de l'aide à tout moment, que ce soit <strong>pour se lancer</strong>/se faire former, ou savoir quoi faire.</p>
</li>
</ol>
<!-- 1. Selon ce qui est adopté cette année, on utilisera un systéme de **Gestion de Projet** (Postit, Trello, ...) pour avoir les tâches en cours et ainsi savoir qui travaille sur quoi.
    + Par exemple, réaliser le cahier des charges, modéliser la base roulante, ...  -->
<h3 id="création-de-comptes"><a class="header" href="#création-de-comptes">Création de comptes</a></h3>
<p>Pour accéder aux outils, vous pouvez également créer les comptes au fur et à mesure de vos besoins, et demander les accès sur Discord.</p>
<ul>
<li><strong>Whatsapp</strong> Si vous avez besoin de communication rapide avec les autres membres (avant/pendant/après un event par exemple)</li>
<li><a href="https://github.com/ENACRobotique"><strong>Github</strong></a> pour partager le code, les cartes électroniques,...</li>
<li><a href="https://www.onshape.com/en/education/sign-up"><strong>Onshape</strong></a> pour la modélisation CAO</li>
</ul>
<h2 id="répartition-des-tâches"><a class="header" href="#répartition-des-tâches">Répartition des tâches</a></h2>
<h3 id="1a2a"><a class="header" href="#1a2a">1A/2A</a></h3>
<p>Auparavant (de ~2015 à 2020), le club était divisé en 2 groupes, chacun faisant un des 2 robots.
D'un côté les 1A et les nouveaux, et de l'autre les 2A, afin d'être généralement regroupés par affinité, emploi du temps (et les 2A étant président &amp; trésorier). Néanmoins, cette approche est devenue compliquée en raison d'un manque de personnes pour réaliser le robot, et le fait que les 2A ont plus de compétence que les 1A ce qu'il fait qu'on refait la roue parfois.</p>
<p>Désormais, <strong>tout le monde travaille sur un seul même robot</strong>, et comme le font beaucoup d'équipe, les <strong>1A</strong> se consacrent surtout sur leur <strong>formation et la réalisation de 'l'expérience'</strong>, tandis que les 2A se consacrent à la transmission et à la réalisation du robot. Selon l'avancée durant l'année, on peut réaliser le second robot, calqué sur le premier avec seulement quelques variations pour ne pas perdre de temps.</p>
<h3 id="les-pôles"><a class="header" href="#les-pôles">Les pôles</a></h3>
<p>Comme de nombreuses équipes, depuis 2022, le club s'organise en "pôle" :</p>
<ul>
<li>Informatique -&gt; Programmation du robot et des outils, de la stratégie, à haut niveau, et des microcontrôleurs, ainsi que comment communique chaque chose entre elle, du réseau,..</li>
<li>Electronique -&gt; Réalisation des cartes electroniques, et programmation des microcontrôleurs avec le pôle informatique.</li>
<li>Mécanique -&gt; Réalisation modélisation et impression 3D, découpage de planches du chassis du robot, assemblage,..</li>
</ul>
<p>Attention il ne faut pas croire que ces pôles sont indépendants, ils sont en réalité intrinsèquement liés ! Vous ferez et verrez de tout afin de comprendre la globalité des éléments en jeux,</p>
<p>Pour la programmation :</p>
<ul>
<li>
<p>Pour ceux qui ont déjà fait beaucoup d'informatique avant, on peut se plonger assez tôt sur ce qui a été fait avant et coder soit même.</p>
</li>
<li>
<p>Pour les <strong>débutants</strong>, les premiers mois, il vaut mieux attendre d'avoir fait des cours de l'ENAC et se concentrer sur des choses simples et laisser les autres/les anciens programmer pour ne pas se démotiver et ne pas perdre trop de temps. On vous a prévu des projets tutoriels pour vous faire les mains !</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="responsabilités---organigramme"><a class="header" href="#responsabilités---organigramme">Responsabilités - Organigramme</a></h2>
<p><img src="organisation/../images/organigramme_2022.png" alt="" title="Organigramme des fonctions au club robot" />
(exemple 2022)</p>
<p>Les responsabilités sont dispatchées par rôles et peuvent varier pour chaque année. Un membre peut occuper plusieurs responsabilités. Ces postes n'engagent que notre organisation et sont indépendants des postes BDE. Par ailleurs seul les postes de président, secrétaire et trésorier comptent pour l'engagement citoyens.
Il est préférable que des habitués du club occupent ces 3 postes afin de gérer le club avec l'expérience de son activité.</p>
<h2 id="achat-de-matériel"><a class="header" href="#achat-de-matériel">Achat de matériel</a></h2>
<p>Nous somme dans un club technique et nous avons souvent besoin de matériel plus ou moins rapidement.
Nous avons une procédure spécifique pour l'achat de matériel alors si tu as quelque chose à acheter pour le club <strong>ne te précipite pas !</strong> Rempli ce <a href="https://docs.google.com/forms/d/e/1FAIpQLSewemz9l3u6HdyPxcGG-J_kMPiQli3SrBmdzFpaJSwKc-ys8Q/viewform?usp=sf_link">Google form</a> et préviens ton président ou le référent du club afin qu'ils prennent une décision. Tu peux le faire même pour ce qui n'est pas urgent afin que nous le référençons.
Voici une liste non exhaustive des fournisseurs que nous utilisons, cherche y le matériel :</p>
<ul>
<li>Kubii</li>
<li>Roboshop</li>
<li>Robomaker</li>
<li>RS</li>
<li>Farnell</li>
<li>Conrad</li>
<li>Dagoma</li>
<li>Amazon ( à éviter  )</li>
<li>Aliexpress ( à éviter )</li>
</ul>
<p>Consulte aussi notre liste de <a href="https://docs.google.com/spreadsheets/d/1TeUoSIWEmzGR8E95UF1ArcKC_Q9ka0XM_hPPcPnf0rE/edit#gid=0&amp;fvid=1951377967">matériel déjà référencé</a>.</p>
<h2 id="organisation-du-google-drive"><a class="header" href="#organisation-du-google-drive">Organisation du google drive:</a></h2>
<p>Vous n'utiliserez pas beaucoupe le drive sauf si vous avez un poste à responsabilité.</p>
<ul>
<li>Docs -&gt; Documents super utiles mais pas toujours bien rangés
<ul>
<li>Coupe XXX
<ul>
<li>Photos de l’année, Outils de communication, Dossiers techniques, specs, cahier des charges, diagrammes,...</li>
</ul>
</li>
<li>Infos sur le club</li>
<li>Graphismes
<ul>
<li>Logo, affiches,...</li>
</ul>
</li>
<li>Tutos &amp; où trouver les infos ( attention certaines ne sont plus au goût du jour !)</li>
<li>Archives réglement</li>
<li>Archives
<ul>
<li>Anciens dossiers coupes</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Uniquement accessible au Trésorier, Président et Secrétaire:</p>
<ul>
<li>Organisation
<ul>
<li>Trésorerie</li>
<li>Membres</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contacts"><a class="header" href="#contacts">Contacts</a></h1>
<p>Que ce soit pour rejoindre le club, demander un partenariat ou nous sponsoriser, vous pouvez nous contacter par mail : <a href="mailto:robotique.enac@gmail.com">robotique.enac@gmail.com</a> ou vias les différents réseaux ci dessous :
<br>
<br></p>
<div style="display: flex; justify-content: center; align-items: center; gap: 100px;">
<a href="https://discord.com/invite/7sPZFxb">
<img src="organisation/../images/discord-icon-2048x2048.png" alt="image" width="100" height="auto" >
</a>
<a href="https://github.com/ENACRobotique/">
<img src="organisation/../images/github-1024.webp" alt="image" width="100" height="auto" >
</a>
<a href="https://www.instagram.com/enacrobotique/">
<img src="organisation/../images/Instagram_icon.png.webp" alt="image" width="100" height="auto">
</a>
<a href="https://www.youtube.com/@enacrobotique2767">
<img src="organisation/../images/youtube_icon.webp" alt="image" width="100" height="auto" >
</a>
</div>
<!-- + [Tik Tok](../udndefined.md) -->
 <!-- (gif rick roll) --><div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-dun-robot"><a class="header" href="#introduction-dun-robot">Introduction d'un robot</a></h1>
<h2 id="comment-réaliser-un-robot-"><a class="header" href="#comment-réaliser-un-robot-">Comment réaliser un robot ?</a></h2>
<p>Tout d'abord, il faut décider de quoi faire -&gt; Il faut rédiger une sorte de cahier des charges.</p>
<p>Ensuite, il faut réunir la liste du matériel nécessaire, lesquels sont à commander par exemple.</p>
<p>Enfin, il faut établir la gestion du projet, c'est à dire savoir qui fait quoi et à quel moment pour ne pénaliser personne dans son travail, c'est à dire décider d'un <strong>calendrier</strong> de formation, de deadlines,...</p>
<p>Ainsi, en ordre d'idée, il faudrait idéalement que le robot roule déjà dès fin décembre, et qu'il soit capable de marquer des points en février.</p>
<p>Exemple de timeline:
<img src="introductions/../images/timeline_projet.png" alt="" title="Exemple de timeline pour le robot sur une année" /></p>
<h3 id="le-cahier-des-charges"><a class="header" href="#le-cahier-des-charges">Le cahier des charges</a></h3>
<p>Pour que tout le monde soit d'accord, il est impératif d'avoir un cahier des charges. Il peut être assez court (quelques pages avec photos), mais il doit contenir l'essentiel, c'est-à-dire identifier à partir du réglement des "fonctions" à réaliser (se déplacer, récupérer X objet, afficher le score,...) afin que tous les membres aient la même idée des objectifs à atteindre.
Pour chaque fonction, il faut des critères avec une valeur de performance à atteindre. Ils peuvent bien évidemment être modifiés au cours de l'année.</p>
<p><a href="https://docs.google.com/document/d/1mrJBK6TYmAEOajHTTRQV775p3FRSDmuo/edit?usp=sharing&amp;ouid=110371115636606943160&amp;rtpof=true&amp;sd=true"><strong>Exemple de rapport avec cahier des charges</strong> pour le mini robot de formation Juin 2022</a></p>
<h4 id="exemple-"><a class="header" href="#exemple-">Exemple :</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Fonction</th><th style="text-align: center">Critère</th><th style="text-align: right">Niveau</th></tr></thead><tbody>
<tr><td>Se déplacer</td><td style="text-align: center">Vitesse max</td><td style="text-align: right">0.8 m/s</td></tr>
<tr><td></td><td style="text-align: center">précision</td><td style="text-align: right">+- 2 cm</td></tr>
<tr><td></td><td style="text-align: center">Accélération min</td><td style="text-align: right">0.3 m.s²</td></tr>
<tr><td></td><td style="text-align: center">Vitesse angulaire max</td><td style="text-align: right">1 rad/s</td></tr>
</tbody></table>
</div>
<h3 id="les-specs-du-robots"><a class="header" href="#les-specs-du-robots">Les specs du robots</a></h3>
<p>L'idée est de recenser toutes les <strong>pièces qui composeront le robot</strong> (même celles imprimées en 3D), et d'indiquer l'état d'avancement (en cours de design/de commande, en cours de test,...). Pour ceux qui sont à commander, c'est le moment de voir le prix pour avoir une idée du budget du robot.
Ensuite, on peut faire l'inventaire de ce qui est nécessaire pour la <strong>carte électronique</strong>.
Enfin, on peut définir comment fonctionnera le code dans les grandes lignes (quel "langage" de communication entre la carte électronique et les ordis, quelles fonctionalités sont impératives, lesquelles sont facultatives,...").</p>
<p><a href="https://docs.google.com/document/d/1sOBxRK2LiSuNzQPDihp1MDDo0q5jfXRSP5_wCl4TWog/edit?usp=sharing">Un exemple de "cahier de specs" (2022)</a></p>
<h2 id="de-quoi-est-constitué-un-robot-"><a class="header" href="#de-quoi-est-constitué-un-robot-">De quoi est constitué un robot ?</a></h2>
<h3 id="base-roulante"><a class="header" href="#base-roulante">Base roulante</a></h3>
<p>La base roulante est tout ce qui permet au robot de "rouler" sur la table. Cela inclut les moteurs, les roues, les capteurs pour se localiser, l'électronique pour le déplacement et la localisation <em>(à l'ENAC généralement une carte électronique assure tout le robot)</em>, et les batteries.
C'est la partie essentielle du robot, à réaliser en premier. Sans base roulante fiable, on ne peut rien faire.</p>
<h4 id="les-robots-différentiels"><a class="header" href="#les-robots-différentiels">Les robots différentiels</a></h4>
<p>Le principe de ces robots est d'avoir 2 roues (généralement centrés sur le robot), avec généralement des patins à l'avant et à l'arrière pour que le robot ne bascule pas. On envoie des consignes de vitesse individuelles à chaque moteur ce qui permet de tourner sur soi-même, d'avancer, ou de faire des trajectoires courbées :</p>
<p><img src="introductions/../images/differential_robot_principle.png" alt="" /></p>
<h4 id="les-robots-omnidirectionnels-"><a class="header" href="#les-robots-omnidirectionnels-">Les robots omnidirectionnels :</a></h4>
<p>Ceux-ci ont la faculté de se déplacer dans <strong>toutes les directions</strong> grâce à la forme spéciale des roues.
Un exemple de gif pour un avec 4 roues :
<img src="introductions/../images/holonome_gif.gif" alt="" /></p>
<p>On peut également en retrouver à 3 roues, généralement pour faire des robots triangulaires. Le seul désavantage des 3 roues est qu'il n'est pas capable de passer par dessus un obstacle, contrairement à celui à 4 roues qui pourrait.
Pour tourner sur lui même, il suffit de faire tourner les 3 roues dans un sens, et pour se déplacer dans une des trois directions, il suffit de faire avancer 2 roues adjacentes (la troisième roue roule "latéralement" =&gt; Pas de frottement )
Le désavantage des robots omnidirectionnels est qu'il est plus compliqué de se repérer dans l'espace avec ceux-là <em>(à voir partie localisation)</em>.</p>
<p><img src="introductions/../images/omni_robot_three_wheel.png" alt="" title="exemple de robot omnidirectionnel à 3 roues" /></p>
<h4 id="la-motorisation"><a class="header" href="#la-motorisation">La motorisation</a></h4>
<p>Des moteurs électriques, assez basique, ~12-18V, 10W grand maximum. Vérifier le couple avec le rayon des roues, le reste au pifomètre.
<a href="https://github.com/VRAC-team/la-maxi-liste-ressources-eurobot#223-moteurs">Des outils pour calculer éventuellement le dimensionnement &amp; les caractéristiques du moteur</a></p>
<h4 id="les-roues"><a class="header" href="#les-roues">Les roues</a></h4>
<p>On retrouve principalement :</p>
<ul>
<li>Des roues en caoutchouc  (classique)</li>
<li>Des roues déjà faites plus exotiques (par exemple des roues de rollers) -&gt; Peuvent endommager la table</li>
<li>Faire les roues soit même en polyuréthane, avec l'intérieur de la roue en impression 3D. L'avantage est que l'on peut dimensionner la roue comme on a besoin, ça accroche mieux que la caoutchouc à la table, et ça ne fait (quasiment) pas de dégats sur la table en cas de dérapage. Parcontre il faut le mouler. <strong>Exemple de roues en 2022 sur le dropbox</strong>
<a href="https://www.youtube.com/watch?v=U-_xxI6qvlg">"Tutoriel pour réaliser les roues"</a></li>
</ul>
<h3 id="base-mécanique"><a class="header" href="#base-mécanique">Base mécanique</a></h3>
<h4 id="forme-du-robot"><a class="header" href="#forme-du-robot">Forme du robot</a></h4>
<p>On retrouve principalement 4 formes possibles :</p>
<ul>
<li>Carrées/Rectangulaire
<ul>
<li><strong>++</strong> Pratique pour se coller à un "mur"</li>
<li><strong>--</strong> Peu optimal pour l'utilisation du périmètre</li>
<li><strong>--</strong> Peut facilement rentrer en collision avec quelque chose en tournant sur lui même (difficile de tourner sur lui même près d'un mur)
<img src="introductions/../images/square_robot.png" alt="" title="robot carré" /></li>
</ul>
</li>
<li>Cylindrique
<ul>
<li><strong>++</strong> Pour le périmètre</li>
<li><strong>--</strong> Peu optimal par rapport à ce qu'on utilise : les actionneurs, les pièces mécaniques, etc... sont généralement rectangulaire
<img src="introductions/../images/rct_toulon.png" alt="" title="robot RCT toulon" /></li>
</ul>
</li>
<li>Hexagonal (is Bestagon)
<ul>
<li><strong>+</strong> Pour le périmètre</li>
<li><strong>+</strong> Bon compromis entre cylindre et rectangulaire pour le placement des objets à l'intérieur.<br />
<img src="introductions/../images/robot_enac_2022.png" alt="Robot Enac 2022" /></li>
</ul>
</li>
<li>Triangulaire
<ul>
<li><strong>++</strong> pour les robots holonomes à 3 roues</li>
<li><strong>++</strong> On a des grands 'plats' et de la mobilité
<img src="introductions/../images/omni_tri.jpg" alt="Robot ENAC 2024" /></li>
</ul>
</li>
</ul>
<h4 id="techniques-de-construction"><a class="header" href="#techniques-de-construction">Techniques de construction</a></h4>
<p>Pour construire mécaniquement le "cadre" du robot, une méthode que l'on utilise souvent au club robot est de mettre une planche à la base du robot avec les roues, 4 profilés (=poutres) en métal et une planche qui fait le "toit". Entre les deux, on peut mettre des planches verticalement ou horizontalement vissés aux profilés.</p>
<p>Pour les profilés :</p>
<ul>
<li>Profilés 20*20, M5, Ecrou en T</li>
<li>Makerbeam
<img src="introductions/../images/maker_beam.jpg" alt="makerbeam" /></li>
</ul>
<p>Pour les planches :</p>
<ul>
<li><strong>Planches en bois</strong></li>
<li>Verre acrylique</li>
<li>en métal</li>
</ul>
<h3 id="capteurs"><a class="header" href="#capteurs">Capteurs</a></h3>
<p>Pour mesurer certaines choses, on peut utiliser :</p>
<div class="table-wrapper"><table><thead><tr><th>Capteur</th><th>Usages</th></tr></thead><tbody>
<tr><td>Pression</td><td>Pour les systèmes pneumatiques (Ventouses) -&gt; savoir si on a attrapé quelque chose</td></tr>
<tr><td>Tension</td><td>Pour le niveau de charge des batteries, mesurer la valeur d'une résistance, ...</td></tr>
<tr><td>Distance TOF (Time Of Flight)/Ultrason</td><td>Permet de mesurer une distance entre le capteur et autre chose en face du capteur, en mesurant le temps que met un rayon laser à se réfléchir pour les TOF ou les ondes sonores pour l'ultrason. On peut utiliser cela pour savoir si on a attrapé un objet par exemple, si il est bien présent, pour savoir s'il y a un autre robot, ... Généralement (mais ça dépend des modèles) ils sont assez précis (1-10mm près) qu'à partir d'une distance de 1-2 cm jusqu'à 1m.</td></tr>
<tr><td>Couleur (ex : TCS34725)</td><td>Pour déterminer une couleur. Ne marche qu'à distance très faible (&lt;1 cm), et il y a une led blanche intégrée pour l'éclairer.</td></tr>
<tr><td>Caméra</td><td>Pour faire de la vision par ordinateur -&gt; Déterminer la position d'un objet, déterminer sa couleur, ... Mais c'est super complexe à mettre en oeuvre donc qu'en dernier recours.</td></tr>
<tr><td>Température</td><td>Pas d'utilité pour la coupe de robot pour l'instant mais ça existe.</td></tr>
<tr><td>Récepteur infrarouge, radio</td><td>utilisable pour la communication sans fil (entre robots)</td></tr>
<tr><td>Interrupteur</td><td>Permet de détecter si le robot ou autre chose est en "contact" physique. Par exemple, on peut en mettre sur le robot à "l'avant" pour savoir s'il est en contact avec le mur et donc si c'est le cas, on sait que la position du robot est contre un mur et on peut "recaler" sa position ainsi.</td></tr>
</tbody></table>
</div>
<p><img src="introductions/../images/exemple_recalage.png" alt="Exemple recalage" /></p>
<h4 id="localisation"><a class="header" href="#localisation">Localisation</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Capteurs localisation (exemples)</th><th>usages</th></tr></thead><tbody>
<tr><td>Encodeur optique (AMT-102V)</td><td>Surtout pour les robots différentiels. Ce sont des dispositifs qu'on met autour d'un axe (par exemple une roue) pour mesurer le nombre de "tours de la roue". En connaissant le diamètre de la roue, on peut connaitre sa distance parcourue. Certains sont déjà intégrés aux moteurs, mais le problème est que si les roues "dérapent", les encodeurs sur le moteur ne sont pas en mesure de le détecter. On retrouve donc dans certains robots des <a href="https://enacrobotique.github.io/doc/rex/concept_meca.html#encodeurs">roues "folles"</a>, qui sont juste sur un axe avec une faible résistance pour mesurer les déplacements d'un robot. <img src="introductions/../images/encodeur.jpg" alt="" /></td></tr>
<tr><td>Capteur optique (Souris, <a href="https://shop.pimoroni.com/products/paa5100je-optical-tracking-spi-breakout?variant=39315330170963">PAA5100JE</a>)</td><td>Placé à distance constante du sol, il filme continuellement le sol et via des algorithmes il détermine le "déplacement" horizontal du robot en déterminant les différences entre les images filmés. La précision n'a pas encore été testé au club robot ENAC mais d'après d'autres clubs, c'est prometteur.</td></tr>
<tr><td>Lidar (2D)(Lidar LD06)</td><td>Le lidar est un capteur laser qui mesure sur un angle important (généralement 360°) les distances périodiquement(~10hz). L'usage principale est de détecter les adversaires ainsi. Un projet testé pour la coupe 2022 était de repérer des points fixes connus sur le terrain, et ainsi de trianguler la position du robot. Sinon on pourrait aussi le mettre proche du sol pour détecter les murets et certains algorithmes sont capable de déterminer les déplacements de cette manière. Pour info, ça existe aussi en 3D mais ça sert à rien pour la coupe et ça coute une blinde. <img src="introductions/../images/lidar_2d.png" alt="Lidar" /></td></tr>
<tr><td>IMU/Centrale inertielle/Accéléromètres</td><td>Pas testé au club robot, une centrale inertielle est un instrument, capable d'intégrer les mouvements d'un mobile pour estimer son orientation, sa vitesse linéaire et sa position. L'estimation de position est relative au point de départ ou au dernier point de recalage.</td></tr>
<tr><td>Vision par ordinateur (Camera/Code Aruco)</td><td>Les codes Aruco sont les sortes de QR code sur le terrain. Des algorithmes sont capables de déterminer avec une caméra leurs positions dans l'espace et donc si on en met un sur le robot, de déterminer la position du robot par rapport aux codes arucos du terrain. mais c'est complexe à mettre en œuvre également.</td></tr>
<tr><td>Triangulisation</td><td>Ultrason, Infrarouge sur les balises fixes, on peut mettre des capteurs/émetteurs ultrason/infrarouges et sur le robot, on peut se trianguler.</td></tr>
</tbody></table>
</div>
<h3 id="actionneurs"><a class="header" href="#actionneurs">Actionneurs</a></h3>
<p>A la base de chaque "mouvement" de robot, on retrouve un moteur (mouvement de rotation). Lorsqu'on a besoin de faire certains types de mouvements, il faut faire des <a href="https://www.alloprof.qc.ca/fr/eleves/bv/sciences/les-mecanismes-de-transformation-du-mouvement-s1437">Transformations</a></p>
<p>Pour attraper les objets, on peut réaliser des "bras" avec un servomoteur qui déplace le bras, et au bout on peut retrouver des :</p>
<ul>
<li>Pince</li>
<li>Ventouse (pneumatique, électrovanne)</li>
<li>Ou pousser directement avec l'actionneur</li>
</ul>
<h3 id="carte-electronique"><a class="header" href="#carte-electronique">Carte electronique</a></h3>
<p>Pourquoi utiliser des circuits électroniques ?
Pensez à un clavier. Vous pouvez connecter tous les interrupteurs d'un clavier avec des fils et des diodes et toutes ces jolies choses, mais vous vous retrouvez avec un merdier. Un circuit imprimé est essentiellement un foutoir de fils qui n'est en fait qu'une carte avec un câblage en cuivre d'un millimètre d'épaisseur qui est bien agencé pour permettre des connexions rapides et cohérentes sans fils, et sur lesquelles on est sur que tout les composants ont la bonne alimentation/courant électrique, et les bonnes connexions pour des protocoles plus complexes entre les composants et le microcontrôleur.</p>
<p><img src="introductions/../images/illustration_pcb.png" alt="" /></p>
<h3 id="microcontrôleur"><a class="header" href="#microcontrôleur">Microcontrôleur</a></h3>
<p><img src="introductions/../images/comparison_microcontroller_2.png" alt="" /></p>
<p>Pin disponible -&gt; Permet de brancher plus de capteurs, actionneurs, et toute sorte de composants électroniques.</p>
<div class="table-wrapper"><table><thead><tr><th>Microcontrôleur</th><th>Capacité de calcul/RAM/Espace</th><th>Pin disponible</th><th>Réseau</th><th>prix(hors pénurie)</th></tr></thead><tbody>
<tr><td><strong>STM32 (français)</strong></td><td>Moyen à fort</td><td>Moyen à fort (~30-60)</td><td>Pas de réseau</td><td>Pas cher</td></tr>
<tr><td><strong>ESP32 (chinois)</strong></td><td>fort à très "fort"</td><td>~20-30</td><td>Wifi, bluetooth</td><td>Pas cher</td></tr>
<tr><td><strong>Arduino</strong> (UK)</td><td>Faible</td><td>~10-20</td><td>Pas de réseau</td><td>Très cher (pour les capacités)</td></tr>
<tr><td><strong>Teensy</strong> (USA)</td><td>Moyen à fort</td><td>Moyen à fort (~30-60)</td><td>Pas de réseau</td><td>Cher</td></tr>
</tbody></table>
</div>
<p>Au niveau de la programmation, généralement, plus c'est simple à programmer, moins il y a de "flexibilité" pour faire des choses complexes. Ainsi, les <strong>arduinos</strong> peuvent être assez limités pour les robots. Simple à utiliser, mais dur lorsque le micocontrôleur doit gérer plein de choses.</p>
<p>Pourquoi ne pas programmer tout le robot sur le microcontrôleur mais qu'on utilise aussi des ordinateurs ?
-&gt; On est obligé d'utiliser des languages "bas niveau"(C, C++) et on pourrait perdre plus de temps à développer des choses avec ces languages qu'en utilisant d'autres plus simples (python,...). C'est compliqué de débugger des choses complexes, et la puissance de calcul reste limité.</p>
<h3 id="ordinateur"><a class="header" href="#ordinateur">Ordinateur</a></h3>
<p>Raspberry pi
<img src="introductions/../images/raspy.jpg" alt="raspberry pi" /></p>
<h3 id="exemple-darchitecture-globale-"><a class="header" href="#exemple-darchitecture-globale-">Exemple d'architecture globale :</a></h3>
<p>Voici un exemple de comment relier tous ces composants :</p>
<p><img src="introductions/../images/schema_robot.png" width=300 /></p> 
<p>Au sommet, on retrouve un embedded computer (-&gt; Raspberry pi), qui commande un "peripheral board" (-&gt; Carte elec à faire durant l'année) et reliés à d'éventuels composants "gourmands" en puissance de calcul(caméra, lidar,...).
Le peripheral board (qui peut être décomposé en plusieurs cartes) lui est connecté à tous les autres composants électroniques.</p>
<h3 id="les-batteries"><a class="header" href="#les-batteries">Les batteries</a></h3>
<p>On utilise des batteries de perceuse (Makita, 18V), sinon les Lipo/Life de hobby king de 12/14V sont très bien, des cellules LifePo4 3.2V
En terme de consommation électrique, en ordre de grandeur on à 2/3A en pic pour les moteurs, et 1/2A pour le reste.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lexique"><a class="header" href="#lexique">Lexique</a></h1>
<p>On regroupe ici du vocabulaire fortement utilisé et qui se maitrise uniquement par la pratique. Donc pas besoin d'essayer de tout retenir le premier jour. Ce n'est pas exhaustif, ces notions sont les parties émergées de l'iceberg de complexité de leur domaines. Dans notre cadre d'application il est rarement nécéssaire d'aller en profondeur. Donc pour des complets débutants il est fortement recommandé d'être humble et d'acceptez de ne pas tout comprendre du premier coup :).
Vous pouvez utiliser Wikipédia ou internet pour plus d'explication.</p>
<h2 id="coupe"><a class="header" href="#coupe">Coupe</a></h2>
<ul>
<li><strong>L'expérience</strong> : chaque année, on doit réaliser un objet à poser automatique que le robot doit déclencher. (Par exemple un phare en 2021, une vitrine d'exposition en 2022, un panier en 2023... ).</li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<ul>
<li>
<p><strong>Haut Niveau</strong> : Désigne généralement les fonctions de l'ordinateur de bord ( souvent une Raspberry pi ). Incluant la prise de décision, le traitement des données, la commande. On peut le voir comme l'intelligence du robot.</p>
</li>
<li>
<p><strong>Bas Niveau</strong> : Désigne les fonctions associées aux microcontrolleurs (souvent des STM32). Incluant la gestion des actionneurs, des capteurs, de l'asservissement. On peut le voir comme le système nerveux du robot.</p>
</li>
<li>
<p><strong>Base roulante</strong> : Ce qui permet au robot de "rouler" : les roues, le moteur, le chassis, les capteurs de "positionnement", l'électronique et le code qui va avec.</p>
</li>
</ul>
<h2 id="microcontrôleurs"><a class="header" href="#microcontrôleurs">Microcontrôleurs</a></h2>
<ul>
<li>
<p><strong>GPIO</strong> : General Purpose Input Output. Désigne des <strong>broches</strong> sur un microcontrôleur ou un microprocesseur que l'on peut configurer pour recevoir ou envoyer des signaux numériques. Ces broches permettent de connecter et de contrôler des composants externes comme des LEDs ou des capteurs. Elles sont couramment utilisées dans des projets électroniques pour interfacer des appareils avec des systèmes comme le Raspberry Pi ou Arduino.</p>
</li>
<li>
<p><strong>ADC</strong> : Analog to Digital Converter. C'est un dispositif qui convertit un <strong>signal analogique</strong>, comme une tension variable, en un <strong>signal numérique</strong> que les ordinateurs et microcontrôleurs peuvent comprendre.</p>
</li>
<li>
<p><strong>UART</strong> : (Universal Asynchronous Receiver-Transmitter) est un dispositif qui permet de communiquer entre deux appareils électroniques via une transmission série asynchrone. Il convertit les données entre les formats parallèle et série, permettant <strong>d'envoyer et de recevoir des données bit par bit sur une seule ligne de communication</strong>. C'est couramment utilisé pour la communication entre microcontrôleurs et périphériques comme les modules Bluetooth ou GPS.</p>
</li>
<li>
<p><strong>I2C</strong> :(Inter-Integrated Circuit) est un protocole de communication série qui permet à plusieurs périphériques électroniques de communiquer entre eux via seulement deux fils : un pour l'horloge (SCL) et un pour les données (SDA). Il est souvent utilisé pour connecter des capteurs, des mémoires, et d'autres composants à un microcontrôleur, en permettant à plusieurs appareils de partager le même bus de communication.</p>
</li>
<li>
<p><strong>Timers</strong> : Les timers sont des composants intégrés dans les microcontrôleurs qui permettent de mesurer des intervalles de temps ou de générer des événements à des moments précis. Ils peuvent être utilisés pour créer des délais, mesurer la durée d'un événement, ou déclencher des actions périodiques, comme faire clignoter une LED ou générer un signal PWM. <strong>On peut les voir comme des compteurs qui comptent les nombres de cycle d'horloge du processeur et déclenche des évènements à partir d'une certaine valeur.</strong></p>
</li>
<li>
<p><strong>Baud</strong> :  Le baud est une unité de mesure représentant le nombre de changements d'état ou de symboles par seconde sur une ligne de transmission. Un symbole peut représenter plus d'un bit si des techniques comme la modulation de phase ou d'amplitude sont utilisées. <strong>Dans notre cas le baud désigne systématiquement le nombre de bits par secondes.</strong></p>
</li>
<li>
<p><strong>Bits par seconde (bps)</strong> : Dans les communications simples, comme celles utilisant le protocole UART (Universal Asynchronous Receiver/Transmitter) dans des microcontrôleurs ou des ordinateurs, chaque symbole correspond généralement à un bit de données. Ainsi, si le baudrate est de 9600, cela signifie que 9600 bits de données sont transmis par seconde.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datasheets"><a class="header" href="#datasheets">Datasheets</a></h1>
<h2 id="cheat-sheets"><a class="header" href="#cheat-sheets">Cheat sheets</a></h2>
<ul>
<li><a href="datasheets/./git-cheat-sheet-education.pdf">Git</a></li>
<li><a href="datasheets/./kicad-cheatsheet-landscape-v8.pdf">Kicad</a></li>
</ul>
<h2 id="micro-controlleur"><a class="header" href="#micro-controlleur">Micro controlleur</a></h2>
<ul>
<li><a href="datasheets/./stm32f401xx.pdf">STM32F401xx</a></li>
<li><a href="datasheets/./stm32g484xe-1.pdf">STM32g484xE</a></li>
<li><a href="datasheets/./NUCLEO_grand-um1724-stm32-nucleo64-boards-mb1136-stmicroelectronics.pdf">NUCLEO-64 </a></li>
<li><a href="datasheets/./NUCLEO_petit-um1956-stm32-nucleo32-boards-mb1180-stmicroelectronics.pdf">Nucleo-32</a></li>
</ul>
<h2 id="capteurs-1"><a class="header" href="#capteurs-1">Capteurs</a></h2>
<ul>
<li><a href="datasheets/./LDROBOT_LD06_Datasheet.pdf">Lidar LD06</a></li>
<li><a href="datasheets/./lsm6dsl.pdf">IMU lsm6dsl</a></li>
</ul>
<h2 id="composants-passifs"><a class="header" href="#composants-passifs">Composants passifs</a></h2>
<ul>
<li><a href="datasheets/BIR-BM1331.PDF">LED</a></li>
</ul>
<h2 id="composants-actifs"><a class="header" href="#composants-actifs">Composants actifs</a></h2>
<ul>
<li><a href="datasheets/./Infineon-IFX9201SG-DS-v01_01-EN.pdf">Pont en H - IFX9201SG</a></li>
<li><a href="datasheets/./Infineon-IRF7404-DataSheet-v01_01-EN.pdf">Mosfet - IRF7404</a></li>
<li><a href="datasheets/./R-78E-1.0.pdf">Régulateur de tension - R-78E</a></li>
</ul>
<h2 id="autres"><a class="header" href="#autres">Autres</a></h2>
<ul>
<li><a href="datasheets/./tuto_board_schematics.pdf">Tuto board schematics</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-bases"><a class="header" href="#les-bases">Les bases</a></h1>
<p>Les bases de la fabrication d'un robot peuvent se simplifier en distinguant trois catégories primaires:</p>
<ul>
<li>L'électronique</li>
<li>L'informatique</li>
<li>La mécanique</li>
</ul>
<p>Ces trois pilliers doivent vivre en symbiose si on veut pouvoir fabriquer un robot. Aussi il est donc nécéssaire d'en avoir les bases et même un peu plus. Mais pas d'inquiétude, l'objectif du club est justement d'avoir ce "plus" au fil de la pratique. Cette section contient plein de liens et de tutoriels pour commencer dans ces trois domaines.</p>
<h1 id="outils-communs"><a class="header" href="#outils-communs">Outils Communs</a></h1>
<p>Au club on utilise linux pour la plupart des trucs. Il est conseillé de l'installer : <a href="bases/./pc/dual_boot.html">Installer un dual boot</a>.</p>
<p>On utilise git pour la gestion de version du code. C'est un outil magique pour travailler à plusieurs sur un projet ! <a href="bases/./pc/git.html">Commencer avec Git</a>.</p>
<p>On utilise actuellement <a href="bases/./info/vscode.html">Visual Studio Code</a> pour le code.</p>
<p>Pour la modélisation 3D on utilise <a href="https://www.onshape.com/en/education/sign-up">Onshape</a>.</p>
<p>Enfin, on utilise <a href="bases/./elec/kicad.html">Kicad</a> pour les cartes électroniques.</p>
<p>Les Ordinateurs du club ont tout d'installés si vous voulez vous y essayer avant.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="bases/info/../../images/info_banner.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vs-code"><a class="header" href="#vs-code">VS Code</a></h1>
<h3 id="editeur-de-texte-"><a class="header" href="#editeur-de-texte-">Editeur de texte :</a></h3>
<p>L'éditeur à utiliser est visual studio code : <a href="https://code.visualstudio.com/">VS code</a>. Vous serez amenés à l'utiliser aussi en cours alors il sera judicieux de l'avoir sur votre machine personnelle.</p>
<p>Pour installer un ".deb" sur ubuntu par exemple, vous pouvez faire :</p>
<p><code>sudo dpkg -i fichier.deb</code></p>
<p>Vous pouvez ensuite installer les extentions C/C++ et Python directement depuis VS code. Ça vous facilitera la lecture des différents codes ainsi que l'auto complétion.</p>
<p><img src="bases/info/../../images/cpp-extension.png" alt="" /></p>
<h3 id="outil-de-compilation-pour-lembarqué"><a class="header" href="#outil-de-compilation-pour-lembarqué">Outil de compilation pour l'embarqué:</a></h3>
<div style="display: flex; align-items: flex-start;">
<a href="http://ajaugust.com/platformio-notes.html" >
<img src="bases/info/../../images/platformio.png" width="800px"> </a>
<div style="padding-left: 30px;">
<p>Une extension de VS code qui permet de compiler vers les microcontrôleurs est
<a href="https://platformio.org/install/ide?install=vscode">platformio</a>.</p>
<p>Vous apprendrez à l'utiliser directement au club lorsque vous aborderez le C++.</p>
</div>
</div>
<p><a href="http://ajaugust.com/platformio-notes.html">What is Platformio ?</a></p>
<p>Il est nécessaire d'installer venv pour que platformIO fonctionne : <code>sudo apt install python3-venv</code>.</p>
<p>Pour linux il faut également rajouter des règles <a href="https://en.wikipedia.org/wiki/Udev"><code>udev</code></a>.</p>
<p>Installer d'abord curl: <code>sudo apt install curl</code></p>
<p>Ensuite vous pouvez taper la commande automagique :</p>
<pre><code class="language-bash">curl -fsSL https://raw.githubusercontent.com/platformio/platformio-core/develop/platformio/assets/system/99-platformio-udev.rules | sudo tee /etc/udev/rules.d/99-platformio-udev.rules
</code></pre>
<p>Ou le faire manuellement en le téléchargeant directement depuis le manuel : <a href="https://docs.platformio.org/en/latest/core/installation/udev-rules.html">udev rules for Platformio</a></p>
<p>Ensuite redémmarez <code>udev</code>:</p>
<pre><code class="language-bash">sudo service udev restart
</code></pre>
<p>ou</p>
<pre><code class="language-bash">sudo udevadm control --reload-rules
sudo udevadm trigger
</code></pre>
<h2 id="résolution-de-problèmes-avec-vs-code"><a class="header" href="#résolution-de-problèmes-avec-vs-code">Résolution de problèmes avec VS-Code</a></h2>
<p>Lorsque vous téléversez du code il est possible que vous rencontriez cette erreur :</p>
<pre><code class="language-bash">Error: libusb_open() failed with LIBUSB_ERROR_ACCESS
Error: open failed
in procedure 'program'
** OpenOCD init failed **
shutdown command invoked

*** [upload] Error 1
=========================== [FAILED] Took 2.36 seconds ===========================

 *  The terminal process "platformio 'run', '--target', 'upload', '--upload-port', '/dev/ttyACM0'" terminated with exit code: 1. 
 *  Terminal will be reused by tasks, press any key to close it. 
</code></pre>
<p>Cela peut être dû à plusieurs choses.</p>
<ul>
<li>Première explication :</li>
</ul>
<p>Vous avez un problème d'alimentation. Essayez un autre câble ou une autre prise usb.</p>
<ul>
<li>Deuxième explication :</li>
</ul>
<p>Regardez le message d'erreur : <code>Error: libusb_open() failed with LIBUSB_ERROR_ACCESS</code>. Souvent sous linux l'accès aux USB est restreint. Il faut donc ajouter des accès pour pouvoir téleverser du code. Le plus problable est que vous n'avez pas ajouté les permissions <code>udev</code> comme précisé plus haut.</p>
<ul>
<li>Troisième explication (Approximative):</li>
</ul>
<p>Un programme est déjà en cour sur le microcontroleur que vous utilisez et le bloque dans une boucle infinie. Cela l'empêche donc de récupérer le programme que l'on veut téléverser. Maintenez le bouton reset, cliquez sur upload et relacher le reset au bout d'une seconde ou deux. Ça ne marchera pas forcément.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bases-de-python"><a class="header" href="#bases-de-python">Bases de Python</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Si vous n'avez jamais programmé en Python, <a href="https://zestedesavoir.com/tutoriels/799/apprendre-a-programmer-avec-python-3/">Zeste de savoir</a> propose une bonne introduction des notions de base (communes à tous les langages), avec un TP pour appliquer directement. Le tuto devrait prendre ~8H à faire au total.</p>
<p>Pour les IENAC, vous aurez des cours de python dès le premier semestre qui vous apprenent des notions très utilisé au club. Il peut être intéréssant donc de ne pas s'y focaliser dans un premier temps et d'apprendre dans d'autre pôles.</p>
<h2 id="le-python-au-club-robot"><a class="header" href="#le-python-au-club-robot">Le python au club robot</a></h2>
<p>Au club robot, nous utilisons le python pour réaliser de nombreux programmes, que ce soit des scripts, des interfaces graphiques ou encore la stratégie du robot. Pour cela, il peut être nécessaire de bien découper le programme, et d'être capable parfois de traiter en temps réel des données provenant d'un autre ordinateur.</p>
<p>#TODO</p>
<p>Vous pourrez consulter ultérieurement :</p>
<ul>
<li>Robokontrol</li>
<li>eCal</li>
<li><a href="bases/info/../../code/index.html">tuto code - architecture globale</a></li>
</ul>
<!-- ## TP - Télécommande robot

*(Durée : Environ 4h)*

Si vous souhaitez prendre en main un exemple de programme que l'on peut être amené à developper au club robot en Python, une bonne introduction consiste à créer une "télécommande" pour un robot simulé.

**//TODO : à rédiger**

Intro robot_sim

Intro robot_kontrol

Intro middleware

Ensuite, Créer un fichier python, avec un publisher de cmd_vel avec eCAL, et voir ce qui se passe sur robot_kontrol

Réaliser un programme qui prend en entrée une lettre, et executer une cmd_vel correspondante (zqsd), et toute autre commande entraine l'arrêt.

Correction :  --><div style="break-before: page; page-break-before: always;"></div><h1 id="la-programmation-pour-lembarqué"><a class="header" href="#la-programmation-pour-lembarqué">La programmation pour l'embarqué</a></h1>
<p>Lorsque vous voulez programmer ( en python par exmple) vous utiliser votre ordinateur et vous y écrivez votre programme. Néanmoins vous avez bien vu que votre ordinateur est peut être un peu encombrant pour un petit robot et puis vous n'avez pas besoin de pouvoir lui brancher un clavier et un écran en permanence. Aussi peut être vous vous voyez mal brancher tout vos composant électroniques directement à votre ordinateur. C'est la qu'intervient la programmation embarqué!</p>
<p>En embarquée vous avez besoin de relier un programme aux circuits électroniques de votre robot afin de pouvoir l'automatiser. C'est là qu'interviennent les circuit éléctoniques programmables, les <strong>microcontrôleurs</strong>. Ils sont généralement programmés en utilisant le language C++ ( dérivé du language C) que vous aprrendrez à utiliser au club.</p>
<p>À préciser que pour ceux qui ont déjà programmé en C et qui n'ont jamais fait d'embarqué qu'il faudra quand même suivre les tutoriels section I.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Il va falloir installer plusieurs choses sur vos ordinateurs :</p>
<h3 id="outils-de-compilation-"><a class="header" href="#outils-de-compilation-">Outils de compilation :</a></h3>
<p>Le C est un language compilé. Sous Linux vous utiliserez <strong>g++</strong> pour compiler votre code. Vous utiliserez également <strong>GDB</strong> pour déboguer. Ces outils ne sont pas installés par défaut sur Ubuntu, vous devez donc les installer. Heureusement, c'est facile.</p>
<p>Nous allons donc installer un ensemble de paquet très utile pour le développement et la compilation sur linux, il contient g++, GDB ainsi que make que vous serez ammené à utiliser plus tard.</p>
<p>Exécutez la commande suivante à partir de la fenêtre du terminal pour mettre à jour les listes de packages Ubuntu. Une distribution Linux obsolète peut parfois interférer avec les tentatives d'installation de nouveaux packages.</p>
<p><code>sudo apt update</code></p>
<p>Installez ensuite le paquet <code>build-essential</code> avec cette commande :</p>
<p><code>sudo apt install build-essential</code></p>
<p>Vous pouvez ensuite vérifier la version de gcc avec : <code>gcc -v</code></p>
<!-- Lien mort [Zeste de Savoir](https://zestedesavoir.com/tutoriels/755/le-langage-c-1/1042_les-bases-du-langage-c/4621_rencontre-avec-le-c/) -->
<h2 id="i---le-c-pour-lembarqué"><a class="header" href="#i---le-c-pour-lembarqué">I - Le C++ pour l'embarqué</a></h2>
<p>Vous aurez un cours pratique sur la <a href="bases/info/../../carte_tuto/tuto_board.html">Carte tuto</a> faite par le club pour découvrir le monde merveilleux de l'embarqué.</p>
<!-- Lien google doc [Carte tuto](https://docs.google.com/document/d/1-jxdJCb0QWJrYiXEooCPBYri_L7LV24AF4ST5_-yBRs/edit)  -->
<p>Il est recommandé ensuite de suivre les tutoriels de <a href="https://zestedesavoir.com/tutoriels/686/arduino-premiers-pas-en-informatique-embarquee/">Zeste de savoir</a> qui vous permettront de vous plonger au cœur du sujet avec des <strong>mises en pratique</strong> et traitant toutes les notions utilisées en embarqué. Dans ce tutoriels c'est une carte arduino qui est utilisée. Nous en avons au club. Néanmoins pour nos robot nous utilisons des cartes ST(celle de la carte tuto!) qui se programment de la même façon, vous pourrez donc vous entrainer directement dessus.</p>
<h2 id="ii---le-c-plus-généralement"><a class="header" href="#ii---le-c-plus-généralement">II - Le C plus généralement</a></h2>
<p>Si vous avez dejà fait du C seule la section précédente vous intéresse.</p>
<p>Le C++ est un dérivé du language C. Pour approfondir votre maîtrise il vous faudra suivre cet autre tutoriel de <a href="https://zestedesavoir.com/tutoriels/755/le-langage-c-1/1042_les-bases-du-langage-c/">Zeste de savoir</a>. Il contient des notions de bases que vous aurez normalement déjà vu et d'autres plus avancées qu'il vous faudra bien connaître également (principalement la notion de <strong>pointeur</strong>).</p>
<h2 id=""><a class="header" href="#"></a></h2>
<p>Les tutoriels sont en français et devraient prendre une dizaine d'heures, n'hésitez pas à survoler certains détails et ne vous embêtez pas à retenir, vous pouvez toujours retrouver le tutoriel si vous avez oublié quelque chose :p (On est pas en examen !). Vous n'êtes pas contraint de maîtriser ces cours avant d'arriver au club. Cependant il faudra y consacrer du temps comme pour tout apprentissage. Et bien évidement <strong>demandez de l'aide si besoin</strong> !</p>
<p>Par exemple, focalisez vous sur les types assez simple (int, float, char), les opérateurs mathématiques basiques, les conditions et les fonctions.</p>
<p>Avec la pratique vous finirez par vous souvenir de ce qui est le plus utilisé dans votre quotidiens.</p>
<!-- Pour l'instant non porté sur le site :
    [Carte tuto](https://docs.google.com/document/d/1-jxdJCb0QWJrYiXEooCPBYri_L7LV24AF4ST5_-yBRs/edit)
    [github associé à la carte tuto](https://github.com/Fabien-B/tutosBoardRoboticClub/) -->
<h2 id="iii---problématiques-robots-embarqués"><a class="header" href="#iii---problématiques-robots-embarqués">III - Problématiques robots embarqués</a></h2>
<p>Ultérieurement, vous pouvez voir les problématiques liées à l'asservissement sur le site de <a href="https://www.pm-robotix.eu/2022/02/02/asservissement-et-pilotage-de-robot-autonome/">PM robotix</a>.</p>
<p>(TODO)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mécanique"><a class="header" href="#mécanique">Mécanique</a></h1>
<h2 id="la-mécanique-au-club"><a class="header" href="#la-mécanique-au-club">La mécanique au club</a></h2>
<p>Un robot, il faut lui donner vie ! Et pour se faire quoi de mieux que deux planches et 3 vis. Bon d'accord c'est plus complexe que ça je te le cède. Le club est un petit atelier équipé de nombreux outils qui te permettrons d'assembler toutes sortes de montages et mécanismes qui constituent le robot. La plupart de nos outils ne nécéssite pas de formation spécifique. Pense néanmoins toujours à ta sécurité quand tu les utilises, si tu as un doute, demande de l'aide car c'est très facile de se blesser.</p>
<p>Nous utilisons aussi le <a href="http://fabric-insa.fr/site/">FabLab de l'Insa</a> qui est très bien équipé. Notamment ils ont une <a href="https://www.autodesk.fr/solutions/cnc-machining-software">CNC</a> et une <a href="https://www.troteclaser.com/fr/apprentissage-et-assistance/faqs/comment-decouper-au-laser">découpeuse laser</a>. L'utilisation des machines se fait facturer à la minute. Il ont aussi un catalogue de noël si vous voulez vous offrir des maquettes à titre <strong>personnel</strong>.</p>
<h2 id="la-cao"><a class="header" href="#la-cao">La C.A.O</a></h2>
<p>Avant de fabriquer le robot il faut le designer. On utilise principalement la <strong>conception assistée par ordinateur</strong> (CAO ou CAD en anglais).</p>
<p>La CAO permet de représenter les objets en deux ou trois dimensions sur un écran. Elle inclut des fonctions multiples comme le calcul numérique, la  modélisation, etc.</p>
<p>Les logiciels de CAO doivent être en mesure de réaliser les tâches suivantes :</p>
<ul>
<li>la manipulation d'objets 2D ou 3D,</li>
<li>la représentation graphique,</li>
<li>le dessin de plan,</li>
<li>la gestion des grands assemblages.</li>
<li>la modélisation numérique,</li>
<li>le calcul numérique,</li>
</ul>
<p>Au club nous l'utilisons essentiellement pour le dessin des pièces et l'assemblage mécanique du robot. Nous ne faisons pas de calcul numérique.</p>
<h2 id="logiciels"><a class="header" href="#logiciels">Logiciels</a></h2>
<p>Initialement le club utilisait <a href="https://www.solidworks.com/">Solidworks</a> pour la modélisation 3D. Depuis la session 2023 le club cherche à migrer vers <a href="bases/meca/../outils_communs/onshape.html">Onshape</a>. La raison principale est qu'il a l'avantage d'être dans le navigateur ce qui rend son utilisation beaucoup plus accessible. Aucune instalation, pas besoin de windows, pas besoin de pc surpuissant. Pour les habitué de solidworks ne vous inquiétez pas, le logiciel est très similaire dans la création des pièces, il faut juste un petit temps d'adaptation. La ou il diffère c'est dans la gestion des versions et des fichiers mais vous verrez ce n'est rien de compliqué c'est même pratique !</p>
<p>Vous pouvez tout de suite commencer en suivant cette <a href="https://www.youtube.com/playlist?list=PLxmrkna-ixrIQmsPR3MITi4Ru1bnMH4-l">série de tutoriel sur youtube</a> comprenant les bases de création d'une pièce et d'utilisation du logiciel.</p>
<!-- En sections que l'on peut également passer : 
Cotation avancé
## Choses à voir : 

Faire 2 piéces simple en impression 3D et les assembler

Voir la bibliothéque d’objets du club

Comment organiser une CAO

Montrer charnière, congé

parler des plans, types de vues

Raccourcis claviers intéressants :
F2 je crois, pour renommer -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="onshape"><a class="header" href="#onshape">Onshape</a></h1>
<p><img src="bases/meca/../../images/onshape_logo.png" width=150 /></p> 
Onshape est un outils de CAO cloudé. On peut y accéder en ligne depuis nimporte quel navigateur (Il existe aussi une application mobile utile pour montrer des designs mais non pratique pour les faire). Pas besoin d'installation juste d'une bonne connexion internet.
Elle permet de faire de la modélisation 3D, des assemblages et de la mise en plan.
Il y'a de la gestion de version similaire à git ce qui est pratique pour faire plusieurs designs en parrallèle.
On peut définir des équipes. Le club vous ajoutera lorsque vous aurez créé votre compte.
Elle permet d'accéder à des bibliothèques partagée de modèles mais aussi de fonction personalisé réalisé par la communauté.
<p>S'inscrire sur <a href="https://www.onshape.com/en/education/sign-up">Onshape</a>.</p>
<h2 id="tutos-onshape"><a class="header" href="#tutos-onshape">Tutos Onshape</a></h2>
<p>(Tutoriel maison avec des images c'est mieux !)</p>
<p>Autres tutoriels :</p>
<ul>
<li>
<p><a href="https://www.youtube.com/playlist?list=PLxmrkna-ixrIQmsPR3MITi4Ru1bnMH4-l">Série de tutoriel sur youtube</a></p>
</li>
<li>
<p>Faire une pièce paramétrée <a href="https://www.youtube.com/watch?v=YRpnTfee34Q">youtube</a></p>
</li>
</ul>
<h2 id="solidworks"><a class="header" href="#solidworks">Solidworks</a></h2>
<p>Le club n'utilise plus solidworks à partir de la rentrée 2023. Néanmoins si vous souhaitez apprendre à utiliser le logiciel il est disponible sur les postes du club. Nous ne l'utiliserons simplement pas pour la conception du robot sauf éventuellemnt dans certains cas très particuliers.</p>
<p>Vous pouvez obtenir une <a href="https://education.solidworks.fr/licence_student_standard_etudiant/">licence étudiante gratuite</a> si vous souhaitez l'installer à titre personnel sur votre machine.</p>
<p>Vous pourrez ensuite suivre les <a href="http://sdz.tdct.org/sdz/apprenez-a-utiliser-solidworks.html#ApprenezutiliserSolidWorks">tutoriels solidworks</a> pour apprendre. Certains membres ont déjà utilisé le logiciels. N'hésitez pas à leur demander conseil.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impression3d"><a class="header" href="#impression3d">Impression3D</a></h1>
<p>Pour le prototypage on utilise beaucoup l'impression 3D
Nous avons à notre disposition une <a href="https://www.flashforge.com/download-center/51">Creator Pro 2</a> que tu apprendras à utiliser bien évidemment! Une fois que tu auras fait ta première pièce il te faudra utiliser le logiciel <a href="https://www.flashforge.com/download-center/63">FlashPrint</a> pour rendre ton modèle 3D lisible pour l'imprimante. <em>( Il n'est pas nécéssaire de l'installer il est sur les postes du club ! )</em> Tu apprendras à tout utiliser lors des sessions de formations.
Tu peux aussi utiliser l'imprimante pour des projets personnels, mais pense à ramener ta bobine (surtout si tu compte imprimer des figurines...).</p>
<h2 id="utiliser-flashprint"><a class="header" href="#utiliser-flashprint">Utiliser Flashprint</a></h2>
<p>(Tuto maison avec des images svp)</p>
<h2 id="changer-le-filament-dimprimante"><a class="header" href="#changer-le-filament-dimprimante">Changer le filament d'imprimante</a></h2>
<p>Creator Pro2</p>
<p>Ultimaker</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="découpe-laser"><a class="header" href="#découpe-laser">Découpe Laser</a></h1>
<h2 id="préparer-un-fichier-de-découpe-avec-inkscape"><a class="header" href="#préparer-un-fichier-de-découpe-avec-inkscape">Préparer un fichier de découpe avec inkscape</a></h2>
<ul>
<li>vectoriser une image ?</li>
</ul>
<h2 id="préparer-un-fichier-de-découpe-avec-onshape"><a class="header" href="#préparer-un-fichier-de-découpe-avec-onshape">Préparer un fichier de découpe avec onshape</a></h2>
<p>Prenons l'exemple de cette useless box dont on aimerait découper les différents pièces :</p>
<p align="center">
    <img src="bases/meca/../../images/laser/useless_box.png"  alt="image" width="500" height="auto">
</p>
<p>Pour pouvoir la découper, il faut passer d'un fichier 3d à 2d. Pour cela, nous utiliserons la feature Auto Layout.</p>
<p>Voici à quoi ressemble le menu lorsque que l'on clique sur l'icône.</p>
<p align="center">
    <img src="bases/meca/../../images/laser/menu_auto_layout.png"  alt="image" width="200" height="auto">
</p>
<ul>
<li><strong>Thickness of material</strong> correspond à la finesse du bois que l'on souhaite utilser</li>
<li><strong>Cut sheet width &amp; Cut sheet height</strong> correspond à la longueur et à largeur de la planche de bois.</li>
<li><strong>Spacing</strong> correspond à l'espace minimal entre 2 pièces</li>
<li><strong>Mutlitple copies</strong> permet de mettre plusieurs fois le projet que l'on souhaite découper (pratique si on veut faire la même découpe plusieurs fois sur la même planche)</li>
<li><strong>Assign oriented faces</strong> permet de forcer le sens de la pièce en mettant la face selection sur le dessus</li>
<li><strong>Show cut sheet on sketches</strong> permet de voir l'esquisse de la taille de la planche</li>
</ul>
<p>Avec les paramètres de la photo précédente, on obtient :</p>
<p align="center">
    <img src="bases/meca/../../images/laser/useless_box_2D.png"  alt="image" width="500" height="auto">
</p>
<p>Maintenant que nous avons nos pièces à plat, on va pouvoir créer le modèle 2D. Pour cela nous allons créer un nouveau dessin avec les paramètres suivant :</p>
<p align="center">
    <img src="bases/meca/../../images/laser/creation_dessin.png"  alt="image" width="500" height="auto">
</p>
<p>Et ensuite on ajoute notre atelier de pièces en cliquant sur :<br />
insérer une vue -&gt; inserer -&gt; document actif -&gt; atelier de pièces -&gt; notre atelier de pièce (ici Part Studio 1).<br />
Après avoir cliqué sur notre pièce, il faut penser à changer l'orientation de la vue par "dessus" avant de la poser sur le dessin</p>
<p align="center">
    <img src="bases/meca/../../images/laser/menu_dessin.png"  alt="image" width="600" height="auto">
</p>
Il ne reste plus qu'à l'exporter au format dxf en faisant un clique droit sur l'onglet du dessin (les différents onglets sont affichés tout en bas).
<h2 id="découpeuse-du-club"><a class="header" href="#découpeuse-du-club">Découpeuse du club</a></h2>
<p>Le club possède une découpeuse laser depuis la rentrée 2024 nous n'avons donc encore rien documenté. Tu sera peut-être celui qui écrira cette section qui sait :) ?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutos-elec"><a class="header" href="#tutos-elec">Tutos elec</a></h1>
<p><img src="bases/elec/../../images/bino_carte.jpg" width=150  /></p>
<p>L'elec de base ce n'est pas sorcier, mais on peut pas l'inventer ! Alors voilà quelques petits tutos en rapport avec l'elec, notamment des schémas pour les circuits les plus courants.</p>
<p>Commencez donc par <a href="bases/elec/led.html">allumer une LED</a> !</p>
<p>Pour les débutants complets voici une série de tutoriels non exhaustif d'<a href="https://www.youtube.com/playlist?list=PLu-QLFNiuxva1LY5CyBa7UJBZkIh5bi_G">éléctronique de base</a> sur youtube.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-led---light-emitting-diode"><a class="header" href="#la-led---light-emitting-diode">La LED - Light Emitting Diode</a></h1>
<!-- > **TL;DR;** Prends entre 300 et 400 ohm. -->
<div style="display: flex; align-items: flex-start;">
<img src="bases/elec/../../images/led_base.png" height="400px" width="auto">
<div style="padding-left: 30px;">
<p>La led, c'est la base. Il faut toujours avoir une LED sous la main. Alors commençons direct :</p>
<ul>
<li>Le premier "composant" (la flèche vers le haut) représente une source de tension continue (on ne travaille qu'en continu).</li>
<li>Le 2ème est une résistance</li>
<li>le 3ème une LED</li>
<li>le dernier, la masse (point où le potentiel vaut 0V)</li>
</ul>
<p>Comme au collège, on suppose que le potentiel est constant le long d'un fil.</p>
<p>La LED est un semi-conducteur qui ne laisse passer le courant que dans un sens, de l'anode (le haut dans ce schéma) vers la cathode (le bas).</p>
<p>Elle a une tension de seuil en deçà de laquelle elle ne s'allume pas. <strong>La résistance est absolument nécessaire afin de ne pas griller la LED, où le système qui l'alimente !</strong></p>
</div>
</div>
<h2 id="calculer-la-résistance"><a class="header" href="#calculer-la-résistance">Calculer la résistance</a></h2>
<p>Pour calculer la résistance, nous devons connaître la tension d'alimentation (ici 5V, nous l'apellerons <strong>Vcc</strong>), la chute de tension aux bornes de la LED <strong>Vd</strong>, et le courant que nous voulons faire passer dans la led <strong>i</strong>.</p>
<p>Admettons pour l'exemple que la chute de tension au borne de la LED soit <code>Vd=1.6V</code>, et nous voulons faire passer un courant de <code>i=10mA</code>.</p>
<ul>
<li>on calcule d'abord la tension au borne de la résistance (loi des mailles): <code>Vr=Vcc-Vd</code> (donc ici: Vr=3.4V)</li>
<li>on calcule ensuite la résistance avec la loi d'ohm (U=RI): <code>R=Vr/i</code> (donc ici: R=3.4/0.01, R=340 ohms)</li>
</ul>
<h2 id="déterminer-les-paramètres"><a class="header" href="#déterminer-les-paramètres">Déterminer les paramètres</a></h2>
<p>C'est bien tout ça, mais comment on trouve <strong>Vd</strong> et <strong>i</strong> ? La réponse se trouve dans un document appelé la <strong>datasheet</strong>.</p>
<p>Ce document existe pour tout les composants électronique, et il faut le consulter avant d'utiliser un composant.</p>
<p>Pour des composants "standards", il n'y aura pas besoin de tout lire, on pourra se concentrer sur quelques infos précises.</p>
<p>Voilà une datasheet pour une LED : <a href="bases/elec/../../datasheets/BIR-BM1331.PDF">BIR-BM1331</a>.</p>
<p>Quelques indices pour lire une datasheet :</p>
<ul>
<li>En haut à doite, il y a généralement le nom des composants décrits par la datasheet.</li>
<li>Ensuite, il y a un desciption synthétique du composant. C'est rapide et facile à lire, et il y a beaucoup d'infos intéressantes, donc c'est à lire !</li>
<li>Il y a généralement une section "Absolute maximum ratings". Si vous dépassez les valeurs données ici, vous allez à coup sûr griller le composant. Il ne faut <strong>jamais</strong> atteindre ces valeurs. Cette partie sert à savoir rapidement si le composant peut convenir pour notre cas ou pas.</li>
<li>Le reste de la datasheet contient toutes les infos nécessaire, c'est là qu'il faudra chercher.</li>
</ul>
<p>Par exemple ici, dans les Absolute maximum ratings, le premier paramètre est "Reverse voltage =&gt; 5V". Ça veut dire que si vous branchez la LED à l'envers sur une alimentation de 5V ou plus, la LED va griller très rapidement.
Plus intéressant pour nous, <em>Continuous forward current 100mA</em>. On sait donc qu'il faudra fixer le courant à <strong>moins</strong> de 100mA.</p>
<p>Pour une LED, on va chercher le courant qu'on va faire passer. C'est pas toujours très clair à trouver, mais ici, un gros indice sont les "test condition" qui prennent <code>If = 50mA</code> ou <code>20mA</code>. C'est bien inférieur à 100mA, on peut donc choisir 20mA.</p>
<p>Ensuite, il faut touver le <em>forward voltage</em> correspondant à ce courant. On peut le lire, assez difficilement grâce à la figure 3: "<em>Forward current vs. Forward Voltage</em>". Pour If=20mA, on trouve environ <strong>Vf=1.2V</strong>.</p>
<p>On peut donc refaire notre calcul de résistance: <code>R=(5-1.2)/0.02</code> donc <code>R=190 Ohm</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifier-un-problème-dans-un-circuit"><a class="header" href="#identifier-un-problème-dans-un-circuit">Identifier un problème dans un circuit</a></h1>
<p>Vous avez monté un circuit et il ne fonctionne pas ? Branché un composant sur un microcontrolleur et copié collé parfaitement le code mais aucune réaction. La dernière fois ça marchait et pas aujourd'hui ? Avant de jetter votre matériel pensez à vérifier l'état de votre circuit ! Pour cela il y 'a plusieurs outils essentiels à savoir utiliser et certaines vérifications à faire.</p>
<h4 id="défaut-dans-un-circuit-ou-sur-une-carte"><a class="header" href="#défaut-dans-un-circuit-ou-sur-une-carte">Défaut dans un circuit ou sur une carte</a></h4>
<p>Tout d'abord il vous faut savoir comment utiliser un <a href="https://www.youtube.com/watch?v=-ovWpR5nECA&amp;t=269s">Multimètre</a>.</p>
<img src="bases/elec/../../images/multimetre.jpg" height ="250px" width = "auto">
<p>Pour détecter rapidement un court circuit ou au contraire si le courant ne passe pas où il devrait, vous pouvez commencer par utiliser le testeur de continuité (icône de diode).</p>
<p><strong>LES CÂBLES</strong> sont très souvent source de problèmes surtout quand il sont de mauvaise qualité. Le courant ne passe pas ou alors passe mal. C'est souvent à cause de cela que certains composants ne réagissent pas ou ont un comportement irrégulier. Si vous avez des fils sertis ou vissés il faut vérifier qu'ils ont correctement été montés.</p>
<p>Une autre chose est de vérifier si il y'a des défauts mécaniques sur la carte. Des soudures ont peut être cédée suite à des chocs. Par exemples les borniers d'alimentations peuvent facilement être arrachés lorsqu'on les visse et qu'on applique trop de force.</p>
<p>Votre microcontrolleur peut être endomagé. Vous pouvez vérifier si les broches fonctionnent en regardant si les changements de tensions suivent un signal que vous attendez ou en utilisant le testeur de continuité.</p>
<p>Un exemple:</p>
<p>En 2024 nous avions branché un driver de stepper à l'envers sur une nucléo l432KC. Le driver à brulé. Après cela nous avions vérifié le circuit qui n'avait pas l'air d'avoir été endomagé. Bien plus tard nous nous étions rendu compte d'une irrégularité dans le contrôle de certains composants. Nous avons donc débugué le code pendant des heures, testé avec plusieurs actionneurs. Et c'est en testant les connexions que nous avons remarqué que l'une des pins de la nucléo ne fonctionnait plus. Au final un simple test au multimètre à suffit...</p>
<h4 id="comment-débuguer-un-signal-complexe-"><a class="header" href="#comment-débuguer-un-signal-complexe-">Comment débuguer un signal complexe ?</a></h4>
<p>Dans le cas ou vous voulez faire passer des signaux plus complexes que du tout ou rien, un multimètre ne suffit pas. Vous pourriez penser à un oscilloscope mais là encore vous ne pourrez pas forcément voir ce que vous voulez. C'est là qu'intervient l'analyseur logique !</p>
<img src="bases/elec/../../images/logic_analyser.jpg" height ="250px" width = "auto">
<p>C'est un outils qui permet d'analyser des signaux logiques et parfois analogiques selon les modèles. On le branche par USB au pc et on utilise un logiciel pour visualiser les signaux qui peuvent être décodés directement.
Vous pourrez normalement le tester avec la carte tuto.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microcontrôleurs-1"><a class="header" href="#microcontrôleurs-1">Microcontrôleurs</a></h1>
<p>On attaque une des briques les plus complexes de notre aventure. Par complexe j'entends copmpléxité technologique. Les microcontrôleurs sont des mini calculateurs programmables qui permettent de commander de l'électronique, des capteurs, des actionneurs. On les retrouve partout dans notre quotidien. Je vous conseille de commencer par regarder ces deux vidéos:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=EeRXSKfaYjA">What is a microcontroller?</a></li>
<li><a href="https://www.youtube.com/watch?v=JwCTkm43CxQ">What is a microcontroller and how microcontroller works</a></li>
</ul>
<p>Vous connaissez peut-être les cartes <a href="https://www.arduino.cc/">Arduino</a>? Ce sont des microcontrôleurs très simplifiés qui permettent d'apprendre beaucoup plus facilement à les utiliser. Ils sont très begginner friendly avec une grande communauté qui répondra à toutes vos questions.</p>
<p>Au club on utilise surtout des STM32, des ESP32 ou des TEENSY. Mais nous avons encore d'autres candidats comme l'attiny...</p>
<p>En ce qui concerne l'utilisation des microcontrôleurs on ne peut comprendre qu'en apprenant, apprendre qu'en essayant. Ainsi nous vous conseillons surtout d'essayer sois avec des kits arduino, soit directement avec la <a href="bases/elec/../tutoboard/tutoboard.html">Carte tuto</a> conçue à cet effet par le club.</p>
<h3 id="comment-choisir-un-bon-µc-"><a class="header" href="#comment-choisir-un-bon-µc-">Comment choisir un bon µC ?</a></h3>
<p>Vous avez d'abord besoin de savoir ce que vous voulez brancher. Cela va définir les fonctions et le nombre de connexions avec le µC. Si vous voulez utiliser du PWM et de l'UART. Si vous avez besoin d'alimenter en 5V et en 3.3V en même temps.</p>
<p>La deuxième étape est de savoir quelles fonctions peuvent marcher en même temps. Il peut arriver par exemple de ne pas pouvoir utiliser les fonctions SPI et UART en même temps. Par exemple sur la <a href="bases/elec/../../datasheets/NUCLEO_petit-um1956-stm32-nucleo32-boards-mb1180-stmicroelectronics.pdf">Nucleo L432KC</a> on ne peut pas utiliser l'I2C et tout les ADC en même temps.</p>
<p>Autre critère, le Wifi et le bluetooths sont déjà intégrés sur les ESP32 mais pas sur les STM32. Cela veut dire que si vous voulez utiliser le wifi sur une stm il faudra un module externe, et donc utiliser des pins. Alors que l'ESP le fait déjà nativement et a des bibliothèques dédiés à cet effet.</p>
<p>La taille de la carte aussi joue un rôle. Certes elles ne sont généralement pas très grandes mais vous pouvez très vite voir qu'entre une L432KC et une F401RE (celle de la carte tuto) l'encombrement peut être handicapant sur un robot de petite taille.</p>
<h4 id="et-si-aucune-carte-nest-vraiment-adapté-à-mes-besoin-"><a class="header" href="#et-si-aucune-carte-nest-vraiment-adapté-à-mes-besoin-">Et si aucune carte n'est vraiment adapté à mes besoin ?</a></h4>
<p>Dans ce cas on passe à l'étape supérieure : fabriquer notre propre µC ! Lisez donc la prochaine section :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kicad"><a class="header" href="#kicad">Kicad</a></h1>
<div style="display: flex; align-items: flex-start;">
<img src="bases/elec/../../images/kicad_icon.webp" height="150px" width="auto">
<div style="padding-left: 30px;">
<p>Kicad est le logiciel nous permettant de créer des cartes électroniques.</p>
<p>Installez le en suivant la procédure décrite sur le site de <a href="https://www.kicad.org/download/linux/">Kicad</a>.
Nous vous conseillons d'installer la dernière Stable release.</p>
<p>Aussi vous pourrez récupérer nos librairies custom si nécéssaire sur <a href="https://github.com/ENACRobotique/kicad_libs_ENAC">Github</a>.</p>
</div>
</div>
<p>Pour commencer vous pouvez visualiser cette vidéo qui montre en 10 minutes comment se déroule une conception de pcb sous Kicad : <a href="https://www.youtube.com/watch?v=3FGNw28xBr0">Kicad in a nutshell</a>. Attention c'est assez rapide.</p>
<p>Lorsque vous travaillez vous voudrez certainement avoir à portée de main la <a href="bases/elec/../../datasheets/kicad-cheatsheet-landscape-v8.pdf">Kicad Cheat Sheet</a> pour augmenter votre rendement.</p>
<h2 id="todo--faire-un-tutoriel-dune-carte-électronique-basique"><a class="header" href="#todo--faire-un-tutoriel-dune-carte-électronique-basique">TODO : faire un tutoriel d'une carte électronique basique</a></h2>
<!-- 
(vrac venant de la carte tuto):
On peut régulièrement trouver les deux manières de brancher une led.
La LED2 est branchée d’une manière plus “logique”, mais il est parfois conseillé de brancher les leds comme la LED1. Les circuits intégrés reçoivent (sink) plus facilement du courant qu’ils n’en fournissent (source). --><div style="break-before: page; page-break-before: always;"></div><h1 id="lordinateur-le-centre-du-monde"><a class="header" href="#lordinateur-le-centre-du-monde">L'ordinateur le centre du monde</a></h1>
<p><img src="bases/linux/../../gifs/destroy_pc.gif" alt="&quot;Mettre image d&#39;un mec qui brise son pc au marteau&quot;" /></p>
<p>Comme tu as pu le constater au centre de tout il y a ton ordinateur. Que ce soit pour la conception, le code ou même l'interface avec les robots, tu as besoin d'un pc opérationel et encore faut-il savoir l'utiliser !</p>
<p>Nous utilisons Linux au club donc cette section comportera principalement des notions liées à son utilisation pour la robotique.</p>
<p>Nous avons 3 ordinateurs fixes principaux : Hal, Giskard et Wall-e ainsi que plusieurs portables possédant tout les outils logiciels évoqués précédement. Nous utilisons Ubuntu (KDE) et changeons régulièrement vers les versions <a href="bases/linux/../../undefined.html">LTS</a> les plus récentes.</p>
<p>Il est important de ne pas négliger l'utilisation du terminal de commande de Linux au risque de vous retrouver bloqué. Les choses à savoir sont simples mais il faut prendre l'habitude de le faire. Soyez attentif aux cours d'Unix-Linux pour ceux qui en feront (IENAC, IESSA), ce sera utile.</p>
<p>Pour les gens qui n'ont jamais utilisé linux, ces quelques vidéos d'introduction peuvent être utiles.</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=pyXYRkB1v28">Linux en 4 min</a></li>
<li><a href="https://www.youtube.com/watch?v=xLhCOFWaY_M">Linux c'est quoi ?</a></li>
<li><a href="https://www.youtube.com/watch?v=HbgzrKJvDRw">Linux file directories explained</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installer-un-dual-boot-linux"><a class="header" href="#installer-un-dual-boot-linux">Installer Un Dual Boot Linux</a></h1>
<p>Développer sous windows peut parfois être un peu compliqué, et comme d'une manière générale <strong>linux c'est mieux</strong>, on va apprendre comment l'installer sur ton ordi.</p>
<p>On va installer un dual boot, c'est à dire que Windows et Linux vont cohabiter sur ton disque dur, et il faudra choisir au démarrage lequel tu voudras lancer. Tu aura donc les performances maximales, mais ne pourra pas etre sur les deux système simultanément.</p>
<p>Il y a de fortes chances que vous appreniez à le faire en cours d'archimat de l'ENAC lors de TP. Vous pourrez donc vous faire la main avant si vous avez peur de tuer votre ordinateur...</p>
<h2 id="préliminaires-sous-windows"><a class="header" href="#préliminaires-sous-windows">Préliminaires sous windows</a></h2>
<p>Comme Windows n'aime pas partager, il faudra d'abord faire quelques réglages sous Windows pour permettre l'installation de Linux à côté de celui-ci. Il est aussi plus sage de sauvegarder toutes tes données importantes sur un support hors de ton PC (clé USB, disuqe dur, ...). Je n'ai jamais eu aucune perte de données, <em>mais</em> <em>comme</em> on joue avec les partitions de son disque dur, on n'est jamais à l'abri d'une erreur ou d'une panne de courant au mauvais moment.</p>
<ul>
<li><strong>Désactiver la mise en veille prolongée :</strong> par défaut, Windows ne s'éteint pas quand on le lui dit mais rentre en veille prolongée, et ça empèche de démarrer sous un autre OS.
<ul>
<li>ouvrir un terminal avec les droits administrateur (clic droit sur le logo windows, shell)</li>
<li>entrer la commande <code>powercfg.exe /hibernate off</code></li>
</ul>
</li>
<li><strong>Reconfigurer le disque en AHCI si besoin :</strong> Sur certains PC récents, les disques utilisent un mode qui n'est pas encore supporté par Linux.
<ul>
<li>Rédémarre ton PC et entre dans les réglages du BIOS (en martelant au démarrage une touche dépendant du PC, en général F2 ou F10). Cherche la mention d'un <strong>SATA mode</strong>, et vérifie qu'il est réglé sur <strong>AHCI</strong>.
<ul>
<li>S'il est bien sur ce mode, passe directement au partitionnement de ton disque.</li>
<li>S'il est réglé sur <strong>RAID</strong> ou un autre truc bizarre (comme <em>RPS with optane</em>), ne le change <strong>pas</strong>, rédémarre ton ordinateur (sur Windows) et suis <a href="http://triplescomputers.com/blog/uncategorized/solution-switch-windows-10-from-raidide-to-ahci-operation/">ce tuto</a> ou <a href="https://www.seeyar.fr/activer-mode-ahci-apres-linstallation-de-windows10-mode-ide/">celui-ci</a> pour reconfigurer le disque en AHCI.</li>
<li>S'il est sur autre chose, renseigne toi !</li>
</ul>
</li>
</ul>
</li>
<li><strong>Partitionner le disque dur :</strong> afin d'éviter tout problème de partionnement à cause de la fragmentation Windows, il vaut mieux utiliser directement les outils de Windows :
<ul>
<li>appuyer sur <code>Windows + R</code></li>
<li>saisir <code>diskmgmt.msc</code></li>
<li>clic droit sur le volume à partitionner (<em>Disque 0</em> par exemple) et sélectionner <code>Réduire le volume</code>. Si tu as plusieurs disques, par exemple un SSD et un HDD, il vaut mieux utiliser le SSD si tu peux pour des raisons de performances, mais ça marchera aussi très bien sur le HDD !</li>
<li>choisir la taille de la partition désirée (Ubuntu demande 15Go minimum et recommande 25Go ; si tu as de la place tu peux libérer un espace de 60Go ou plus !)</li>
</ul>
</li>
</ul>
<p>Ton disque dur a maintenant un espace inutilisé, il est temps de l'utiliser !</p>
<h2 id="installer-linux"><a class="header" href="#installer-linux">Installer Linux</a></h2>
<p>Il existe beaucoup de distributions Linux, et nous allons ici voir comment installer Ubuntu, qui reste simple et adapté à nos besoins. Tu auras besoin d'une clé USB (attention, la clé sera formatée).</p>
<h3 id="préparez-une-clé-bootable"><a class="header" href="#préparez-une-clé-bootable">Préparez une clé bootable</a></h3>
<ul>
<li>Télécharge l'ISO de la dernière LTS : <a href="https://ubuntu.com/download/desktop">https://ubuntu.com/download/desktop</a></li>
<li>Flash l'ISO ainsi téléchargé sur ta clé. Si tu ne sais pas faire, je te conseille d'utiliser <a href="https://www.balena.io/etcher/">Etcher</a> qui permet de faire ça en 4 clics :
<ul>
<li>"Select Image" t'invite à choisir l'ISO que tu as déjà téléchargé.</li>
<li>"Select Drive" te demande de choisir le disque à flasher. Sois bien sûr de choisir la clé USB, et pas autre chose !</li>
<li>"Flash!" lance l'opération et raconte ce qu'il fait à ta clé au fur et à mesure.</li>
</ul>
</li>
<li>Une fois la clé flashée, redémarre ton ordinateur et entre das les réglagles du BIOS.
<ul>
<li>Désactive le <code>UEFI Secure Boot</code> qui t'empècherait de démarrer sur ta clé.</li>
<li>Désactive le <code>Fast Start-Up</code> si cette option existe.</li>
<li><em>Optionnel</em> : Change l'odre de priorité pour booter sur la clé USB avant le disque dur.</li>
<li>Sauvegarde les modifications et quitte le BIOS. Ton ordi va redémarrer.</li>
</ul>
</li>
<li>Si tu as changé l'ordre de priorité du boot, l'ordinateur devrait redémarrer sur Linux. Sinon, démarre manuellement sur la clé en pressant la touche appropriée (souvent F12 ou F2).</li>
<li>Sélectionne "try Ubuntu"</li>
</ul>
<p>Ubuntu devrait alors démarrer, et tu peux le tester. Passons maintenant à l'installation !</p>
<h3 id="installation-dubuntu"><a class="header" href="#installation-dubuntu">Installation d'Ubuntu</a></h3>
<p>On va d'abord créer les partions nécessaires à Ubuntu. Il est possible de faire tout ça directement depuis l'installeur, mais je préfère le faire avant, l'interface étant plus claire !</p>
<ul>
<li>démarre le programme <code>gparted</code></li>
<li>sélectionne le disque où tu as libéré de l'espace pour Linux</li>
<li><em>Optionnel mais recommandé :</em> Crée un partition de type <code>swap</code> d'une taille égale à la taille de ta RAM.</li>
<li>Crée une partition de type <code>ext4</code>. Si tu as réservé plus de 40Go pour linux, fais la d'environ 25 ou 30 Go, et crée une autre partition <code>ext4</code> sur la place restante. Cela permettra de changer facilement de version d'Ubuntu sans perdre de réglages ni de données.</li>
<li>Applique les modifications (ça peut prendre du temps), et quitte gparted.</li>
</ul>
<p>Tout est prêt, allons-y !</p>
<ul>
<li>démarre l'installeur (il doit être sur le bureau).</li>
<li>Lorsqu'on te demande où installer le système Linux, choisis <em>Autre chose</em> (ou <em>Something else</em>).</li>
<li>Sélectionne la partion <em>swap</em> que tu as crées et configure la en <code>type: swap</code> (ça devrait être déjà fait)</li>
<li>Sélectionne la première (ou seule) partition <em>ext4</em> que tu as créée, et configure la en <code>type: ext4</code> et <code>mount point: /</code> en la formatant.</li>
<li>Si tu as créée une deuxième partition <em>ext4</em>, configure la en <code>type: ext4</code> et <code>mount point: /home</code>.</li>
<li>Laisse l'emplacement du démarrage à sa valeur par défaut, qui devrait être le disque ou tu as Windows.</li>
<li>Continue avec la suite de l'installation, qui devrait être assez simple, et prendre un certain temps (~20 min). Tu peux utiliser ton ordinateur pendant ce temps.</li>
<li>Quand l'installation sera terminée, Ubuntu te proposera de rédémarrer sur ton nouveau système. Accepte, et retire la clé de l'ordinateur lorsque l'ordinateur est éteint.</li>
</ul>
<p>Au démarrage du PC, tu devrais maintenant atterrir sur une interface te permettant de choisir entre Ubuntu ou Windows. Teste les deux options pour vérifier que tout marche bien.</p>
<p>Passe au chapitre suivant pour installer les outils courants du club.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<div style="display: flex; align-items: flex-start;">
<img src="bases/linux/../../images/github-1024.webp" height="150px" width="auto">
<div style="padding-left: 30px;">
<p>Git est un gestionnaire de version qu'on utilise pour gérer le code. Il permet entre autres de facilement collaborer à plusieurs sur un même code, ou encore de revenir à une version antérieur d'un fichier. Il est très utilisé par les pro mais nous vous encourageons à l'utiliser même pour des projets personnels tellement il est pratique.</p>
</div>
</div>
<h2 id="mise-en-place"><a class="header" href="#mise-en-place">Mise en place</a></h2>
<ul>
<li>
<p>se créer un compte sur <a href="https://github.com">Github</a></p>
</li>
<li>
<p>donner son nom d'utilisateur à un responsable du club afin qu'il vous ajoute à l'organisation <a href="https://github.com/ENACRobotique">ENACRobotique</a></p>
</li>
<li>
<p>installer git :</p>
<ul>
<li>Linux : <code>sudo apt install git</code></li>
<li><a href="https://git-scm.com/download/win">Windows</a></li>
<li><a href="https://git-scm.com/download/mac">MacOS</a></li>
</ul>
</li>
<li>
<p>configurer son email et son nom :</p>
<ul>
<li><code>git config --global user.name "Michel"</code></li>
<li><code>git config --global user.email "michel.du@pont.fr"</code></li>
</ul>
</li>
</ul>
<p>Afin de faciliter l'utilisation de github, il est conseillé de créer une paire de clés SSH et de d'ajouter la clé publique à votre compte github. Cela permettra de pusher vos modif sans taper votre login/mot de passe à chaque fois :</p>
<ul>
<li>
<p>créer un paire de clés :</p>
<ul>
<li>ouvrir un terminal et lancer <code>ssh-keygen</code></li>
<li>Garder le chemin par défaut</li>
<li>Ne pas mettre de passphrase pour n'avoir rien à taper lors d'un push
(faites "Entrée" plusieur fois sans rien taper).</li>
<li>Vous pouvez visualiser la clé avec <code>cat ~/.ssh/id_rsa.pub</code>
certain pourront avoir un autre nom de fichier terminant par .pub</li>
</ul>
</li>
<li>
<p>Ajouter la clé à votre compte github :</p>
<ul>
<li>connectez vous à <a href="https://github.com">Github</a>, et allez dans vos Settings à l'onglet <a href="https://github.com/settings/keys">SSH and GPG keys</a></li>
<li>Cliquez sur <a href="https://github.com/settings/ssh/new">New SSH key</a></li>
<li>Entrez un titre pour vous rappeler à quel ordinateur cette clé est liée</li>
<li>copiez collez la totalité de votre clé publique (ce qui sort de <code>cat ~/.ssh/id_rsa.pub</code>)</li>
<li>Cliquez sur New SSH key</li>
<li>Confimez votre mot de passe</li>
</ul>
</li>
</ul>
<p>Vous pourrez maintenant cloner les dépôt github en utilisant SSH plutôt que HTTPS en cliquant sur <em>Use SSH</em> dans la petite fenêtre pour obtenir l'adresse du dépôt.
L'adresse du dépôt devrait ressembler à ça : <em>git@github.com:ENACRobotique/doc.git</em></p>
<p><img src="bases/linux/../../images/git_ssh.png" alt="" title="Clone avec SSH" /></p>
<h1 id="utilisation"><a class="header" href="#utilisation">Utilisation</a></h1>
<p><a href="bases/linux/git@github.com:ENACRobotique/tutogit2020.git">Lien vers le git de tuto</a></p>
<p>Vous aurez un cours sur l'utilisation de base de git. Plus que de simple commande il y'a aussi tout un concept à comprendre que vous serez ammené à maitriser avec l'usage. Vous pouvez retrouver un récap des commandes de bases ici : <a href="bases/linux/../../datasheets/git-cheat-sheet-education.pdf">Git cheat sheet</a>.</p>
<blockquote>
<p>A savoir : Github n'est pas Git !!! Github est un serveur qui heberge des repos Git. Et Git est le logiciel qui peut d'ailleur fonctionner sans internet. Il faut plutôt le voir comme "Github utilise Git".</p>
</blockquote>
<h1 id="tuto-rapides"><a class="header" href="#tuto-rapides">Tuto rapides</a></h1>
<ul>
<li>
<p><a href="https://www.freecodecamp.org/news/git-revert-commit-how-to-undo-the-last-commit/">Revert un commit</a></p>
</li>
<li>
<p><a href="https://www.curiouslychase.com/posts/fix-git-submodule-add-a-git-directory-is-found-locally-issue/">Supprimer des sous modules proprement avec git</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="le-ssh"><a class="header" href="#le-ssh">Le SSH</a></h1>
<p>Au club le robot possède un ordinateur de bord (une raspberry pi). Dès qu'on veut intéragir avec on ne va pas brancher un clavier et un écran dessus à chaque fois. Surtout que lors des tests le robot bouge.
Pour communiquer entre plusieurs machines depuis le terminal on utilise la connection ssh. Elle permet d'intéragir depuis le terminal de la machine utilisée directement dans le terminal de la machine de destination.</p>
<p>Voici les commandes les plus utilisées au club :</p>
<p>Pour avoir un accès distant à la console d'un autre ordinateur :<br />
<code>ssh &lt;utilisateur&gt;@&lt;nom_machine&gt;</code></p>
<p>On peut également ajouter l'option -X pour accéder aux applications graphiques :<br />
<code>ssh -X &lt;utilisateur&gt;@&lt;nom_machine&gt;</code></p>
<p>Pour copier un fichier :<br />
<code>scp &lt;fichier&gt; &lt;utilisateur&gt;@&lt;nom_machine&gt;:&lt;DestinationDirectory&gt;</code></p>
<p>Sources :</p>
<ul>
<li><a href="https://doc.ubuntu-fr.org/ssh">Doc Ubuntu</a> (recommandé)</li>
<li><a href="https://fr.wikipedia.org/wiki/Secure_Shell">Wikipédia</a></li>
<li><a href="https://www.cloudflare.com/fr-fr/learning/access-management/what-is-ssh/">Forum </a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commande-bash-utiles"><a class="header" href="#commande-bash-utiles">Commande Bash Utiles</a></h1>
<p>Petite liste non exhaustive de commandes bash et de leur applications. On ne peut pas toujours tout deviner.</p>
<p>La <strong>première chose à faire</strong> est toujours de taper <code>man [cmd]</code> où &lt;&lt;[cmd]&gt;&gt; est le nom de la commande à utiliser. La deuxième chose est d'utiliser internet.</p>
<h3 id="dmesg"><a class="header" href="#dmesg"><code>dmesg</code></a></h3>
<p>L'option <code>-w</code> peut être utilisée pour observer les connexions et déconnexions de périphérique en temps réel et l'option <code>-e</code> permet rendre tout ça lisible. Par exemple en tapant complètement <code>sudo dmesg -we</code>:</p>
<p><img src="bases/linux/../../images/dmesg_1.png" alt="" /></p>
<p>On peut voir qu'a 23h57 un périphérique USB à été branché. On à l'information de quel USB il s'agit Il s'agit d'un Smartphone model Redmi Note 8 Pro du constructeur Xiami. On à même le numéro de série et on est donc capable de l'identifier de façon unique. En regardant sur internet je vois qu'il s'agit d'un téléphone. En effet j'avais besoin de transférer queslques photos ! On peut voir qu'il a été débranché 11 secondes plus tard.</p>
<p>Ensuite 4 secondes plus tard :</p>
<p><img src="bases/linux/../../images/demesg_2.png" alt="" /></p>
<p>Le début est similaire mais cette fois pas de mystère, nous avons branché une de nos <a href="bases/linux/../../carte_tuto/tuto_board.html">cartes tuto</a> pour la programmer. Or nous cherchons ici à faire de la communications en UART avec elle mais nous ne trouvons pas sur quel port addresser la liaison. Bien sûr nous avons déjà cherché dans le <code>/dev</code> mais il y'a tellement de périphérique qu'on ne s'y retrouve plus. Heureusement il y'a cette ligne :</p>
<p><code>[  +0,000679] cdc_acm 1-5:1.2: ttyACM0: USB ACM device</code></p>
<p>Qui nous indique que le périphérique est bien sur le <code>/dev</code>, plus précisément sur <code>/dev/ttyACM0</code>.</p>
<p>Pour aller plus loin on peut utiliser <code>udevadm info -a /dev/ttyACM0</code>. On ne va pas le montrer car c'est une pluie d'informations mais qui peut néanmoins se montrer utile en fonction du besoin.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-tutoboard-enac"><a class="header" href="#la-tutoboard-enac">La tutoboard Enac</a></h1>
<h1 id="présentation"><a class="header" href="#présentation">Présentation</a></h1>
<p>Les microcontrôleurs  sont de petits ordinateurs intégrés dans une puce. Ils incluent un processeur, de la mémoire, et des périphériques d’entrées sorties.</p>
<p>Il y en a dans quasiment tous les appareils électriques, du grille-pain à la voiture.
Sur la carte tuto, il y en a deux : un <a href="bases/tutoboard/../../datasheets/NUCLEO_grand-um1724-stm32-nucleo64-boards-mb1136-stmicroelectronics.pdf">STM32F4</a>, qui est au centre de la Nucleo (la carte blanche), et un ATtiny1616, à droite de la Nucleo, sous le rond de LEDs.
Il y en a même un autre sur la Nucleo, en bas à gauche de la prise USB, qui va servir à programmer le STM32F4.</p>
<p>Ils exécutent un seul programme, qui démarre dès la mise sous tension.</p>
<p>La tuto board est un outil d'apprentissage crée par et pour le club. Vous pouvez consulter le projet sur Github: <a href="https://github.com/Fabien-B/tutosBoardRoboticClub/">Git de la tuto board</a></p>
<div style="display: flex; align-items: flex-start;">
<img src="bases/tutoboard/../../images/tuto_board.jpg" height="350px" width="auto">
<div style="padding-left: 30px;">
<p>Le but de cette carte est de pouvoir apprendre tout les concepts de base de l'utilisation des microcontrôleurs tout en sachant où commencer. Le club dispense généralement un cours au format travaux pratique sur cette carte. Ce cours peut aussi être réalisé depuis chez soi car le matériel est assez compact pour être emporté (mais la carte s'appelle reviens) et le cours est documenté dans les section qui suivent.</p>
</div>
</div>
<h2 id="les-périphériques"><a class="header" href="#les-périphériques">Les périphériques</a></h2>
<p>Les périphériques sont des circuits électroniques dédiés à certaines tâches, et sont connectés au CPU (processeur) pour intéragir avec le programme.</p>
<p>Quelques périphériques (<a href="bases/tutoboard/../../introductions/lexique.html">Lexique</a>):</p>
<ul>
<li>GPIO : general purpose input output. permet de commander des broches en sorties, ou de lire des broches en entrées</li>
<li>ADC : analog to digital converter. Permet de de lire une tension analogique.</li>
<li>UART : protocole de communication simple</li>
<li>I2C : protocole de communication un peu plus complexe</li>
<li>Timers : des compteurs qui permettent de faire plein de trucs utiles avec le temps, comme par exemple du PWM (on verra ce que c’est plus tard)</li>
</ul>
<p>Ces périphériques sont connectés à certaines broches du microcontrôleur. On devra donc choisir quelles broches utiliser suivant ce que l’on veut faire.</p>
<h2 id="arduino"><a class="header" href="#arduino">Arduino</a></h2>
<p>Pour citer wikipédia :</p>
<div style="display: flex; align-items: flex-start;">
<a href="
https://www.arduino.cc/" >
<img src="bases/tutoboard/../../images/arduino_icon.png" width="500px"> </a>
<div style="padding-left: 30px;">
<blockquote>
<p>Arduino est la marque d'une plateforme de prototypage open-source qui permet aux utilisateurs de créer des objets électroniques interactifs à partir de cartes électroniques matériellement libres sur lesquelles se trouve un microcontrôleur.</p>
</blockquote>
</div>
</div>
<p>Dans notre cas, on va surtout utiliser les librairies arduino, qui vont nous permettre de programmer très simplement le microcontrôleur. Vous pouvez retrouver les références du langage dans la <a href="https://docs.arduino.cc/language-reference/">Documentation Arduino</a>.</p>
<blockquote>
<p>Note:
Attention cependant : cette librairie nous cache beaucoup de complexité, on peut donc être surpris par un comportement “bizarre” lorsqu'on utilise beaucoup de fonctions sur beaucoup de broches simultanément.
Exemple vécu l’année dernière : les moteurs qui font un bruit chelou quand on essaie d’utiliser des servos.</p>
</blockquote>
<h2 id="préparons-nous"><a class="header" href="#préparons-nous">Préparons nous</a></h2>
<p>Pour ces tutos, on va utiliser VSCode avec l’extension PlatformIO, qui va nous permettre d’installer très facilement tout ce qui est nécessaire pour programmer le microcontrôleur.</p>
<p><a href="bases/tutoboard/../../bases/info/vscode.html">VSCode</a></p>
<p>Pour commencer, créez un nouveu projet PlatformIO (icône d'alien dans le menu à gauche). Choisissez la carte correspondante à celle que vous utilisez (Nucleo F401RE par exemple), et avec le framework Arduino.
<img src="bases/tutoboard/../../images/platformio_project.png" alt="" /></p>
<p>Dans un projet arduino, il y a toujours deux fonctions qui sont créées par defaut: setup et loop.
La fonction setup sera exécutée une seule fois au démarrage du programme, et la fonction loop sera appelée en boucle. Voici ce que vous devriez voir :</p>
<img src="bases/tutoboard/../../images/vs_code_project.png">
<p>Vous pouvez effacer les deux <code>myFunction</code> qui ne seront pas utiles.</p>
<p>Note:
En réalité, la fonction main du programme est codée comme ceci:</p>
<pre><code class="language-cpp">int main(){
    setup();
    for(;;) {
        loop();
    }
}
</code></pre>
<p>Le <code>for(;;)</code> étant juste une autre manière d’écrire <code>while(true)</code> en se la pétant et en économisant 4 caractères.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-bases-1"><a class="header" href="#les-bases-1">Les bases</a></h1>
<h3 id="led"><a class="header" href="#led">Led</a></h3>
<p>On va commencer par le “hello world” de la programmation embarquée : faire clignoter une led !</p>
<p>Regardez le <a href="bases/tutoboard/../../datasheets/tuto_board_schematics.pdf">schéma</a> de la carte tuto : on va faire clignoter la LED2 (qui est dans le cadre “Basics” ), qui est connectée à la broche PC8 du microcontrôleur ( le bloc au centre ).</p>
<h4 id="configuration"><a class="header" href="#configuration">Configuration</a></h4>
<p>La broche doit d’abord être configurée en sortie. Cela permettra ensuite de la mettre à l’état logique haut ou bas, ce qui se traduira par une tension entre GND et la broche de 3.3V ou 0V.
La fonction pour configurer une broche en entrée ou sortie s’appelle pinMode: <code>void pinMode(int pin, int mode);</code>
Elle prend en premier argument la broche à configurer, en en deuxième argument le mode. Les deux modes principaux sont INPUT et OUTPUT. Il en existe d'autres que nous verront plus tard.</p>
<p>On va donc configurer la broche comme ceci, dans la fonction setup:</p>
<pre><code class="language-cpp">void setup() {
  pinMode(PC8, OUTPUT);
}
</code></pre>
<h4 id="commander-létat"><a class="header" href="#commander-létat">Commander l’état</a></h4>
<p>On va ensuite changer l’état de la broche grâce à la fonction digitalWrite: <code>void digitalWrite(int pin, int val);</code>
Elle prend en premier argument la broche, et en deuxième l’état à écrire : HIGH ou LOW.
On va aussi utiliser la fonction <code>delay</code> qui met le programme en pause durant un certain temps (en millisecondes).</p>
<p>On écrira donc dans la fonction loop:</p>
<pre><code class="language-cpp">void loop() {
  digitalWrite(PC8, HIGH);	// set PC8 to HIGH
  delay(500);			// wait 0.5 seconds
  digitalWrite(PC8, LOW);	// set PC8 to LOW
  delay(500);			// wait 0.5 seconds.
}
</code></pre>
<p>Compiler (Build), puis flasher (Upload) le microcontrôleur grâce à ces deux boutons (en bas de l'application):</p>
<div style="display: flex; justify-content: center; gap: 100px;">
  <img src="bases/tutoboard/../../images/pio_build.png" style="width: auto; height: 80px;">
  <img src="bases/tutoboard/../../images/pio_upload.png" style="width: auto; height: 80px;">
</div>
<p>Un terminal devrait s'ouvrir, il faut attendre. La première fois cela peut être plus long car VS code peut vouloir installer des outils suplémentaires. Vous devriez voir le message suivant :</p>
<p><code>==== [SUCCESS] Took 14.34 seconds ====</code></p>
<p>La LED2 doit donc maintenant clignoter.</p>
<blockquote>
<p>Note : Il est possible que vous aillez une erreur de téléversement à ce moment, surtout si c'est la première fois. Consulter la section <a href="bases/tutoboard/../../bases/info/vscode.html">VS Code &amp; Platformio</a> peut vous aider.</p>
</blockquote>
<p>Changez le programme pour la faire clignoter plus vite, ou de manière asymétrique: des flashs brefs séparés par un temps assez long.</p>
<h4 id="améliorer-son-code"><a class="header" href="#améliorer-son-code">Améliorer son code</a></h4>
<p>On se réfère toujours à la broche par son nom: <code>PC8</code>. Ce n’est pas très explicite. On va donc faire ce qui s'appelle un <code>define</code>.
Ajoutez cette ligne au dessus de la fonction setup : <code>#define LED2 PC8</code></p>
<p>C’est une directive de préprocesseur, qui sera appliquée avant la compilation et qui va remplacer toutes les occurrences de <code>LED2</code> trouvées dans le code par <code>PC8</code>.
Cela nous permet donc d’écrire un code plus explicite. Vous pouvez donc écrire <code>LED2</code> à la place de <code>PC8</code> dans tous les appels de fonctions.</p>
<p>Vous pourrez remarquer au passage que HIGH et LOW ne sont que des <code>define</code> pour 1 et 0.</p>
<blockquote>
<p>Note:
En C, une expression booléenne est vraie tant qu’elle est différente de 0.
Vous pouvez remplacer HIGH et LOW par un entier dans la fonction <code>digitalWrite</code>, ça marchera toujours.</p>
</blockquote>
<h4 id="une-autre-led"><a class="header" href="#une-autre-led">Une autre led</a></h4>
<p>Tout en gardant votre code, faites clignoter la LED1  (PB1) au même rythme.
Qu'observez-vous ?
La LED1 est dans l’état opposé à la LED2. Observez le <a href="bases/tutoboard/../../datasheets/tuto_board_schematics.pdf">schéma</a> électronique pour comprendre pourquoi.</p>
<p>Faites les clignoter de la même manière.</p>
<img src="bases/tutoboard/../../images/led_tuto_board.png" height="200px" width="auto">
<blockquote>
<p>Note:
On peut régulièrement trouver les deux manières de brancher une led.
La LED2 est branchée d’une manière plus “logique”, mais il est parfois conseillé de brancher les leds comme la LED1. Les circuits intégrés reçoivent (sink) plus facilement du courant qu’ils n’en fournissent (source).</p>
</blockquote>
<h3 id="boutons"><a class="header" href="#boutons">Boutons</a></h3>
<p>On a appris à configurer une broche en sortie pour écrire son état, on va maintenant faire l’inverse: lire l’état d’une broche.</p>
<blockquote>
<p>Note: Avant de commencer, assurez-vous que les jumpers JP1 et JP2 sont montés. On verra plus tard à quoi ils servent.</p>
</blockquote>
<div style="display: flex; align-items: flex-start;">
<img src="bases/tutoboard/../../images/tuto_board_jumpers.jpg" height="150px" width="auto">
<div style="padding-left: 30px;">
<p>On peut brancher facilement les jumpers avec des petits connecteurs. À gauche le jumper JP2 déconnecté à droite le jumper JP1 connecté.</p>
</div></div>
<p>La suite est très similaire à ce que l’on vient de faire : il faut maintenant configurer la pin en entrée (dans la fonction setup): <code>pinMode(BTN2, INPUT);</code>.
Puis on va lire l’état de la broche grâce à la fonction digitalRead:
int digitalRead(int pin);
Elle prend en argument la pin à lire, et retourne l’état de cette pin.</p>
<p>On va donc écrire ce code dans la fonction loop pour récupérer l’état du bouton, et allumer une led en conséquence :</p>
<pre><code class="language-cpp">int etat = digitalRead(BTN2);
digitalWrite(LED2, etat);
delay(10);
</code></pre>
<p>Compilez, flashez, testez.</p>
<p>Changez le temps du delay pour 1000. Que se passe t’il ?
La led met longtemps à réagir car le programme est en pause, et ne fait un tour de boucle que toutes les secondes !</p>
<blockquote>
<p>À savoir : La fonction <code>delay</code> est ce qu'on appelle une fonction "bloquante". Lorsqu'elle est exécutée aucune autre instruction ne sera exécutée. Çela peut être un problème et dans ce cas on cherchera à utiliser des fonctions "non bloquantes". Dans le cas présent ce n'est pas très important. On vera cela ultérieurement.</p>
</blockquote>
<p>Remettez un delay raisonnable (moins de 100ms pour que ce soit réactif), et utilisez maintenant BTN1. Que se passe t’il ?
Pourquoi ?</p>
<blockquote>
<p>Note: Dans les schémas suivants, les petites résistances sont des résistances de protection que vous pouvez ignorer. Ignorez donc R13 et R14.</p>
</blockquote>
<h4 id="intérêt-des-pullup-et-pulldown"><a class="header" href="#intérêt-des-pullup-et-pulldown">Intérêt des pullup et pulldown</a></h4>
<p>Enlevez les jumpers. Est-ce que ça marche toujours aussi bien ? (non).</p>
<img src="bases/tutoboard/../../images/bouton_tutoboard.png" width="auto" height="300px">
<p>Explication : Les résistances R11 et R12 sont ce qu’on appelle des résistances de pullup et de pulldown.</p>
<p>Sans les jumpers, quand le bouton ne fait pas contact, la pin est “en l’air” : elle n’est connectée ni à la masse, ni au 3.3V.</p>
<p>Une broche en entrée est dans un état dit “haute impédance” : le courant d'entrée est très faible (idéalement 0), comme si la broche n’était pas reliée au reste du circuit.</p>
<p>Le potentiel (tension par rapport à la masse) de cette pin est donc indéfini, et va varier au gré des perturbations électromagnétiques environnantes.
C’est donc le rôle des résistances de pullup / pulldown de fixer le potentiel de la broche à une valeur connue.</p>
<p>Prenons le cas de R11, sur BTN1 (le jumper JP1 étant connecté):
Quand le bouton n’est pas pressé, BTN1 est connecté au 3.3V à travers de la résistance R11.Le courant d’entrée du microcontrôleur étant nul, le courant traversant cette résistance vaut donc 0. D’après U=RI, on en déduit donc que la tension aux bornes de R11 est nulle, et donc que le potentiel de BTN1 vaut 3.3V.</p>
<p>Quand le bouton est pressé, si on ignore R13, BNT1 se retrouve donc directement connecté à GND. Le potentiel est donc de 0, et on lira donc un état bas.</p>
<p>La tension aux bornes de R11 sera donc de 3.3V, et on peut déduire le courant qui la traversera par I=U/R. Ici on aura donc I = 3.3/10 000 = 0.33mA.</p>
<p>Une résistance de pullup / pulldown aura souvent un ordre de grandeur d'environ 10KOhm : Cela permet d’avoir une faible consommation d’énergie tout en remplissant parfaitement sa fonction.</p>
<h5 id="mais-r13--elle-existe-en-vrai-"><a class="header" href="#mais-r13--elle-existe-en-vrai-">Mais R13 ? Elle existe en vrai !</a></h5>
<p>Oui, elle existe. On peut calculer gâce à la formule du pont diviseur de tension la tension réelle de BTN1 quand le bouton est pressé:
VBTN1 = (3.3 * R13) / (R13 + R11) = 0.03 V
Cette tension est très proche de 0, bien en dessous du seuil maximal de détection d’un niveau bas.</p>
<h5 id="cest-pas-un-peu-trop-compliqué-pour-un-bouton-"><a class="header" href="#cest-pas-un-peu-trop-compliqué-pour-un-bouton-">C’est pas un peu trop compliqué pour un bouton ?</a></h5>
<p>Eh oui, c’est la vie.
Mais comme on a très souvent besoin de résistances de pullup ou de pulldown, elles sont déjà intégrées dans le microcontrôleur ! Il suffit de les activer.</p>
<p>Enlevez les jumpers, et modifiez la manière dont sont configuré les broches:</p>
<pre><code class="language-cpp">pinMode(BTN1, INPUT_PULLUP);
pinMode(BTN2, INPUT_PULLDOWN);
</code></pre>
<p>Maintenant ça devrait très bien marcher même sans les jumpers !</p>
<blockquote>
<p>Note:
La manière la plus “logique” de connecter le bouton serait la manière dont est branché BTN2. Cependant, dans beaucoup de microcontrôleurs, il n’y a pas de résistance de pulldown, mais seulement des résistances de pullup.
On prend donc l’habitude de connecter les boutons comme BTN1</p>
</blockquote>
<p>Remarque:
Les résistances R13 et R14 ne sont pas nécessaires. Il faut cependant faire très attention: imaginons que la broche BTN1 soit configurée en sortie (OUTPUT), et commandée à l’état haut. Appuyer sur le bouton va donc créer un court-circuit entre le 3.3V et la masse au sein même du microcontrôleur, ce qui risque fort de le griller.
Si on garde R13, elle va limiter le courant à I=U/R = 3.3/100 = 33mA, ce que le microcontrôleur est capable de supporter.</p>
<h3 id="signaux-analogiques"><a class="header" href="#signaux-analogiques">Signaux analogiques</a></h3>
<p>Jusqu'à présent nous regardion uniquement des signaux logiques. Hors les physiciens parmis vous me dirons qu'il existe aussi des signaux qui varient de façon contine ou encore des signaux analogiques. Les µC tel que la F401RE sont capables de lire des signaux analogiques et d'en générer indirectement.</p>
<h4 id="lecture-dun-potentiomètre"><a class="header" href="#lecture-dun-potentiomètre">Lecture d'un potentiomètre</a></h4>
<blockquote>
<p>Avant de faire cette partie regardez comment configurer le moniteur série à la page suivante !</p>
</blockquote>
<p>Repérez sur le schéma le potentiomètre dans le bloc BASICS. Et sur la carte tuto près des boutons que nous avons utilisé précédement.</p>
<img src="bases/tutoboard/../../images/potar_tuto.png" width="auto" height="150px" >
<p>Le potentiomètre ou Potar dans le jargon repose sur le principe du <a href="https://fr.wikipedia.org/wiki/Diviseur_de_tension">pont diviseur de tension</a>. Tourner la molette change la valeur d'une resistance variable qui fera donc varier le potentiel à la broche <code>POT</code> lié a la nucléo.</p>
<p>Les broches analogiques sont des Analog to Digital Converter ou en français Convertisseur Analogique Numérique ( ADC ou CAN ). Les capteurs de manière générale renvoient un signal de tension continue mais les µC ne peuvent traiter que des signaux numériques. L'ADC va donc discrétiser le signal entre deux valeurs, ici 0 et 3.3V, souvent avec une résolution de 10 bits. C'est à dire qu'il renvoient une valeur entre 0 et 1023.</p>
<p>Configurez le broche <code>POT</code>en <code>INPUT</code> (les adc peuvent aussi être utilisé comme gpio). Pour visualiser le signal il faut utiliser le moniteur série, rajouter dans le <code>setup</code> l'instruction <code>Serial.begin(115200);</code> pour l'initialiser.</p>
<p>On veut lire et afficher en boucle la valeur lue par le potar. On rajoute donc les instructions suivantes dans le <code>loop</code> :</p>
<pre><code class="language-cpp">  int potar_value = analogRead(POT); // Lire la valeur de la pin POT
  Serial.println(potar_value); // écrire la valeur dans le moniteur série
</code></pre>
<p>Si maintenant vous tournez le potar, vous verrez la valeur varier. Pas forcément sur tout l'interval car cela dépend des valeurs limites de la résistance du potar. Pour moi par exmple je lis de 10 à 1014.</p>
<h4 id="générer-un-signal-analogique"><a class="header" href="#générer-un-signal-analogique">Générer un signal analogique</a></h4>
<p>Comme précédement les signaux du µC étant numérique on veut les rendre analogique on utilise donc un Digital to Analog Converter (DAC ou CNA). Une façon de réaliser est la PWM, regardez la vidéo de <a href="https://www.youtube.com/watch?v=CSReyYwbGRY">U=RI</a>.</p>
<p>Nous allons, comme montré dans la vidéo, piloter une led de sorte à la faire clignoter plus ou moins fort. Si vous regardez sur la carte tuto il y a des broches sur lesquelles il est écrit PWM. Seules ces broches sont capables de générer ces signaux. Ici les broches <code>PC8</code> et <code>PB1</code> sont toutes les deux capables de faire du PWM. (Rapidement: vous pouvez trouver cette information dans la documentation <a href="bases/tutoboard/../../datasheets/stm32f401xx.pdf">stm32f401xx</a> page 42, il est écrit <code>TIMx_CHx</code> dans la colonne alternate function ce qui signifie que l'on peut utiliser le pwm ).</p>
<p>Comme indiqué dans la vidéo, les valeurs que l'on peut écrire sont entre 0 et 255. Pour ce faire nous allons utiliser la fonction <code>map</code> qui sert à faire une règle de trois en une ligne sans se fatiguer. Puis nous allons écrire sur la broche avec <code>analogWrite</code>. On a changé le print pour plus de visibilité :</p>
<pre><code class="language-cpp">  int led_value = map(potar_value, 0, 1023, 0, 255);
  analogWrite(LED1, led_value);
  analogWrite(LED2, led_value);
  Serial.printf("potar = %d, led = %d \n", potar_value, led_value); // format plus lisible 
</code></pre>
<p>Vous devriez voir les deux leds briller en fonction de la valeur du potar, avec une petite surprise...</p>
<ul>
<li>(TODO) Utiliser l'analyseur logique pour visualiser le signal PWM</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-communications"><a class="header" href="#les-communications">Les communications</a></h1>
<h3 id="introduction-au-serial"><a class="header" href="#introduction-au-serial">Introduction au serial</a></h3>
<p>Pour communiquer entre le pc et une carte électronique, un moyen souvent utilisé est la <a href="https://fr.wikipedia.org/wiki/Transmission_s%C3%A9rie">transmission Série</a> ou Serial. C’est un protocole de communication qui a l’avantage d’être simple et surtout, facilement programmable. Le principe est qu'un seul bus de données relie deux appareils et permet la communication en envoyant un par un les trames de données. <strong>En gros on les relie par un fil...</strong></p>
<h4 id="communication-avec-le-pc"><a class="header" href="#communication-avec-le-pc">Communication avec le pc</a></h4>
<p>Comment utiliser le serial pour débugger, sans rentrer du tout dans les détails :</p>
<p>Pour utiliser le serial il faut modifier le fichier <code>platformio.ini</code> et y rajouter l'instruction <code>monitor_speed = baudrate</code>.</p>
<img src="bases/tutoboard/../../images/pio_ini.png" height="300px" width="auto">
<p>Ensuite pour accéder au moniteur série il suffit de cliquer sur l'icone en bas de l'écran :</p>
<img src="bases/tutoboard/../../images/tuto_board_serial.png" height="100px" width="auto">
<blockquote>
<p>Si vous faisiez le tuto <em>Lecture d'un potentiomètre</em>, pas besoin d'aller plus loin dans l'immédiat. Vous devriez pouvoir lire des messages du moniteur.</p>
</blockquote>
<p>Avec maintenant un peu plus de détails :</p>
<p>La manière la plus courante pour communiquer entre un PC et une carte embarquée est via les ports USB des 2 objets en question.
Ainsi, repérez le port mini usb sur la nucleo, puis branchez y l’adaptateur USB-microUSB jusqu’au PC.
Qu’est-ce qu’il se passe sur le PC ?
Rien d’apparent, mais sous linux, les périphériques sont situés dans le dossier <code>/dev/tty</code>.</p>
<p>Dans le terminal faites <code>ls /dev/tty*</code></p>
<p>Vous devriez avoir avec cette commande plein de résultats. Maintenant débranchez l'usb et refaite la commande. Vous devrier en avoir un de moins. Si vous jouez au 7 différences vous devrier en trouver un du genre <code>ttyACMX</code>. Moi par exemple j'ai  <code>ttyACM0</code>. C’est notre nucleo ! Ensuite, on utilise la bilbiothèque Arduino qui utilise les standards de <code>print</code> du C/C++.</p>
<p>Pour configurer le serial on rajoute dans le setup <code>Serial.begin(baudrate);</code>, ou baudrate et le nombre de <a href="bases/tutoboard/../../introductions/lexique.html">BAUD</a>, dans le cas présent cela signifie le nombre de bits par seconde. Ici utilisez la valeur <code>115200</code>.</p>
<p>Maintenant pour envoyer un message dans le moniteur série on peut faire <code>Serial.print("Salut les enaciens !");</code> dans le setup.</p>
<p>Pour formater un message on à plusieur solutions.</p>
<ul>
<li>On peut spécifier la Base à utiliser ou l'arrondi pour un nombre par exemple:</li>
</ul>
<pre><code class="language-cpp">Serial.print(78, BIN) donne "1001110"
Serial.print(78, OCT) donne "116"
Serial.print(78, DEC) donne "78"
Serial.print(78, HEX) donne "4E"
Serial.print(1.23456, 0) donne "1"
Serial.print(1.23456, 2) donne "1.23"
Serial.print(1.23456, 4) donne "1.2346"
</code></pre>
<ul>
<li>On peut mélanger du texte et des nombres avec <code>printf()</code>.</li>
</ul>
<p>Par exemple pour votre led à la page précédente nous avions fait</p>
<pre><code class="language-cpp">Serial.printf("potar = %d, led = %d \n", potar_value, led_value);
</code></pre>
<p><code>%d</code> sert à signifier qu'un type <code>int</code> va venir se mettre là,  puis on le passe en argument c'est <code>potar_value</code>. Il faut respecter l'ordre dans lequel on l'écrit. On peut utiliser <code>%f</code> pour un float et il en existe d'autres, cherchez <strong>Format Specifiers</strong> sur internet.</p>
<h3 id="uart"><a class="header" href="#uart">UART</a></h3>
<p>L'Universal Asynchronous Receiver Transmitter ou <a href="https://fr.wikipedia.org/wiki/UART">UART</a> est un composant matériel qui permet l'échange de données entre deux appareils utilisant le protocole série.</p>
<div style="display: flex; align-items: flex-start;">
<img src="bases/tutoboard/../../images/uart.webp" height="150px" width="auto">
<div style="padding-left: 30px;">
L'UART est simple à mettre en œuvre car il ne nécessite que deux fils pour la communication (TX pour transmettre et RX pour recevoir), en plus d'une masse commune (GND). Le TX et RX sont désigné du point de vue de l'appareil. Dans notre pratique il y'a souvent un 4e fil pour l'alimentation.
</div>
</div>
<p>La transmission est <strong>asynchrone</strong> c'est à dire qu'il n'y a pas de signal d'horloge pour synchroniser les messages. Au lieu de cela on utilise un bit de Start et un ou deux bits de Stop pour chaque donnée.
Il ya aussi optionellement un bit de parité utilisé pour la détection d'erreurs placé en amont des bits de stop. La vitesse de transmission est en Baud.</p>
<img src="bases/tutoboard/../../images/Constitution_trame_uart.png" height="100px" width="auto" >
<h4 id="communiquer-avec-le-moniteur-série"><a class="header" href="#communiquer-avec-le-moniteur-série">Communiquer avec le moniteur série</a></h4>
<p>L'UART est ce qui nous permet de communiquer entre le pc et le microcontrôleur. En fait lorsque vous utilisez le <code>Serial</code> avec la carte tuto vous faîtes déjà de l'UART ! Mais maintenant vous voulez aussi aller dans l'autre sens.
Avant le setup et le loop ajouter <code>String msg;</code> c'est la variable qui va stocker notre message. Puis dans le loop :</p>
<pre><code class="language-cpp">if (Serial.available()) // Vérifie s'il y a des données disponibles
{ 
    msg = Serial.readString();  // lit la valeur qu'on a envoyé et l'enregistre dans la variable msg
    Serial.println(msg);  //Affiche le texte contenu dans msg sur le moniteur
}
</code></pre>
<p>Accedez au moniteur série et cliquez dans le terminal. Vous pouvez maintenant écrire ici. Le texte ne s'affiche pas quand vous écrivez, mais la réponse de la carte s'affichera.</p>
<img src="bases/tutoboard/../../images/Moniteur_serie.png" height="200px" width="auto">
<h4 id="faire-communiquer-deux-appareils"><a class="header" href="#faire-communiquer-deux-appareils">Faire communiquer deux appareils</a></h4>
<p>En pratique vous voudrez surement faire communiquer plusieurs cartes. Dans notre cas, on fait très souvent communiquer une raspberry pi avec une STM32. Dans ce cas il faut donc du code des deux cotés. Pour le coté raspberry vous allez utiliser votre pc et python, ça reviens exactement au même. On ne va pas entrer dans les détails coté python alors copiez collez le code ci dessous. Il faut peut être changer le <code>/dev/ttyACM0</code> par celui que vous avez. Vous pourrier avoir besoin de la bibliothèque <code>pyserial</code> faite <code>pip install pyserial</code> dans votre terminal. Et si vous n'avez pas pip, intstallez pip.</p>
<pre><code class="language-py">import serial
from time import time
if __name__ == "__main__":
    ser = serial.Serial('/dev/ttyACM0', 115200)  # open serial port
    print(f"\nTutoboard sur le port: {ser.name} vitesse : {ser.baudrate}") # check which port was really used
    i = 0
    add = 1
    t = time()
    while True:
        if i == 9 :
            add = -1
        if i == 0:
            add = 1
        if time() - t &gt; 0.1 : 
            i = i + add
            message = str(i) + "\n" 
            ser.write(bytes(message, "ascii")) # write a string
            t = time()
        msg = ser.read()
        print(f"Je lis : {msg.hex()}\n")
        
        # Si vous utilisez write() dans le bas niveau
        # msg = ser.read()
        # print(f"Je lis : {msg.hex()}\n")

</code></pre>
<p>Maintenant du coté bas niveau :</p>
<p>Pour rendre ça un peu plus interactif on va faire clignoter les leds en fonction de ce que nous dis le haut niveau et dire au haut niveau la valeur du potar qui gère l'autre led.</p>
<p>Il nous faut d'abord un <strong>buffer</strong> c'est à dire un espace mémoire qui va contenir la donnée entrante. Nous allons communiquer des messages au format <a href="https://fr.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange">ASCII</a>. Chaque caractère est codé sur 7 bits. Ici on s'attend à recevoir 2 octets (ou bytes en anglais), le premier étant un entier entre 0 et 9 et le second <code>\n</code>permet d'indiquer la fin du message. En embarqué on est plutôt du genre à vouloir toujours connaître la taille des données que l'on manipule. La mémoire étant limitée on voudrait éviter des dépassements de mémoire (ou Buffer Overflow). On va donc rajouter <code>#define BUFFER_SIZE 2</code> au début de notre code.</p>
<p>On va créer des fonctions.</p>
<ul>
<li>Pour la récéption :</li>
</ul>
<pre><code class="language-cpp">int receive()
{
    if (Serial.available() &gt; 0)  // Vérifie s'il y a des données disponibles
    {
        char buffer[BUFFER_SIZE]; // On crée notre buffer pour stocker la donnée
        Serial.readBytesUntil('\n', buffer, BUFFER_SIZE); // Lit les données jusqu'a \n avec un maximum d'octet dicté par BUFFER_SIZE

        // on converti la chaine de carractère en l'entier équivalent 
        // pour pouvoir faire des opérations Attention ça ne marche pas avec les lettres !
        char *output;
        int val = strtol(buffer, &amp;output, 10); // base décimale
        return val;
    }
  return -1;
}
</code></pre>
<p>Attention à faire la différence entre le caractère <code>char</code> qu'est <code>'\n'</code> et la chaine de carractère <code>"\n"</code> stocké sous forme de liste de <code>char</code>. La fonction peut être placée avant ou après le loop. Si elle est placée après, le compilateur vous dira qu'elle n'existe pas. Il faut alors rajouter <code>int receive();</code> en amont.</p>
<ul>
<li>Envoi d'un message :</li>
</ul>
<p>La c'est facile, comme on l'a dit plus tôt il suffit de faire un <code>print</code> pour écrire sur le serial.</p>
<pre><code class="language-cpp">void send(int val)
{ 
  Serial.println(val);
  delay(100);
  // Serial.write((byte)val); // ne mettez pas print et write en même temps !
}
</code></pre>
<p>Dans certain cas on peut aussi vouloir envoyer des données binaires, on utilise alors <code>write</code>. Par contre il faut changer les deux dernières lignes du code python par :</p>
<pre><code class="language-py">msg = ser.read()
print(f"Je lis : {msg.hex()}\n")
</code></pre>
<p>Votre loop devrait tout simplement ressembler à ça :</p>
<pre><code class="language-cpp">void loop() {
  
  // On lis le potar, on envoie sa valeur dans le serial et on pilote la led 
  int potar_value = analogRead(POT);
  int led1_value = map(potar_value, 0, 1023, 0, 255);  
  analogWrite(LED1, led1_value);
  send(led1_value);

  // On lit dans le serial la valeur a appliquer à la led
  int msg = receive();
  if (msg!=-1)
  {
    int led2_value = map(msg, 0, 9, 0, 255);
    analogWrite(LED2, led2_value);
  }
}
</code></pre>
<p>Et voilà vous pouvez téléverser. Ensuite dans votre terminal faîtes <code>python3 tuto_uart.py</code> pour lancer le programme python. Vous devriez lire la valeur du potar dans le terminal et voir l'une des led clignoter lentement sur la carte.</p>
<blockquote>
<p>Attention vous ne pourrez pas ouvrir le moniteur série en même temps que le code python tourne. Vous ne pouvez pas accéder deux fois au même port série. Vous risquez d'avoir des instabilités voire directement une erreur.</p>
</blockquote>
<ul>
<li>(TODO) Visualiser l'UART sur l'analyseur logique.</li>
</ul>
<h3 id="todo-i2c"><a class="header" href="#todo-i2c">(TODO) I2C</a></h3>
<blockquote>
<p>Note : Récement il y'a l'emergence de l'I3C un successeur de l'i2C et rétro-compatible avec les matériels I2C. Ça à l'air intéréssant.</p>
</blockquote>
<ul>
<li>(TODO) Visualiser les trames sur l'analyseur logique</li>
</ul>
<h3 id="communication-avec-la-attiny-1616-"><a class="header" href="#communication-avec-la-attiny-1616-">Communication avec la attiny 1616 :</a></h3>
<!-- [TODO : mettre un easter egg sur l’attiny] -->
<!-- Explication du code :

Vous recevez des caractères étranges et vides de sens, pourquoi ?

-> Baud rate
Il faut le passer à 57600[ou autre] pour lire ce qu’on a caché dans l’attiny. --><div style="break-before: page; page-break-before: always;"></div><h1 id="attiny-protocol"><a class="header" href="#attiny-protocol">Attiny protocol</a></h1>
<blockquote>
<p>Cette section à été rédigée en anglais et ne sera volontairement pas traduite. En tant que roboticiens vous aurez à lire des datasheet en anglais uniquement. Ce n'est vraiment pas évident au début, alors ça vous servira d'entrainement ; )</p>
</blockquote>
<p>The Attiny1616 featured in the tuto board controls 9 leds, and has 2 inputs : a potentiometer and a phototransistor, acting as light sensor.</p>
<p>The protocol documented here allows you to interact with the Attiny.</p>
<p>Packets sent by the nucleo to the Attiny will be called Tx packets. Those sent by the Attiny to the nucleo will be called Rx packets.</p>
<p>Message format
All messages have the same format :</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">STX</th><th style="text-align: center">LEN</th><th style="text-align: center">PAYLOAD[...]</th><th style="text-align: center">CHK</th></tr></thead><tbody>
</tbody></table>
</div>
<p><strong>STX</strong>
Start of the packet. STX=0xFF.</p>
<p><strong>LEN</strong>
Byte size of the PAYLOAD and CHK field.</p>
<p><strong>PAYLOAD</strong>
See Tx packets and Rx Packets.</p>
<p><strong>CHK</strong>
Checksum for the packet.
CHK = ~(LEN + PAYLOAD[0] + … + PAYLOAD[N])</p>
<h2 id="tx-packets"><a class="header" href="#tx-packets">Tx packets</a></h2>
<p>Payload of Tx packets is made of a 1 byte instruction optionally followed by parameters.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">STX</th><th style="text-align: center">LEN</th><th style="text-align: center">INSTRUCTION</th><th style="text-align: center">PARAM 1</th><th style="text-align: center">...</th><th style="text-align: center">PARAM N</th><th style="text-align: center">CHK</th></tr></thead><tbody>
</tbody></table>
</div>
<p>The instructions are:</p>
<p><strong>PING</strong></p>
<ul>
<li>Value: 0x01</li>
<li>Parameters: None</li>
<li>Description: Ping the Attiny.</li>
<li>Answer: PONG message.</li>
</ul>
<p><strong>READ</strong></p>
<ul>
<li>Value: 0x02</li>
<li>Parameters: Address (1byte), count (1byte)</li>
<li>Description: Request the values of the &lt;count&gt; registers, starting at &lt;address&gt;. Answer: REG message.</li>
</ul>
<p><strong>WRITE</strong></p>
<ul>
<li>Value: 0x03</li>
<li>Parameters: address, value1, value2, …</li>
<li>Description: Write the &lt;values&gt; at registers starting at &lt;address&gt;. The register address is auto-incremented.</li>
<li>Answer: None</li>
</ul>
<h2 id="rx-packets"><a class="header" href="#rx-packets">Rx packets</a></h2>
<p>Payload of Rx packets is made of a 1 byte identifier optionally followed by data.</p>
<p><strong>PONG</strong></p>
<ul>
<li>Value: 0x11</li>
<li>Data: no data</li>
</ul>
<p><strong>REG</strong></p>
<ul>
<li>Value: 0x12</li>
<li>Data: values</li>
</ul>
<p><strong>CONTINUOUS</strong></p>
<ul>
<li>Value: 0x13</li>
<li>Data: 2 bytes defined as follow:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">data_id[1:0]</th><th style="text-align: center"><strong>RESERVED</strong></th><th style="text-align: center">data[9:8]</th><th style="text-align: center">data[7:0]</th></tr></thead><tbody>
</tbody></table>
</div>
<p>Where <code>data_id</code> identify the nature of the data:
0x0: potentiometer value
0x1: light value
0x2: leds status</p>
<p>The data itself spans over 10 bits for potentiometer and light values, and 9 bits for leds status.</p>
<h2 id="registers-description"><a class="header" href="#registers-description">Registers description</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Name</th><th style="text-align: center">Address</th><th style="text-align: center">Rights</th></tr></thead><tbody>
<tr><td style="text-align: center">POT_L</td><td style="text-align: center">0X00</td><td style="text-align: center">R</td></tr>
<tr><td style="text-align: center">POT_H</td><td style="text-align: center">0X01</td><td style="text-align: center">R</td></tr>
<tr><td style="text-align: center">LIGHT_L</td><td style="text-align: center">0X02</td><td style="text-align: center">R</td></tr>
<tr><td style="text-align: center">LIGHT_H</td><td style="text-align: center">0X03</td><td style="text-align: center">R</td></tr>
<tr><td style="text-align: center">LEDS_L</td><td style="text-align: center">0X04</td><td style="text-align: center">RW</td></tr>
<tr><td style="text-align: center">LEDS_H</td><td style="text-align: center">0X05</td><td style="text-align: center">RW</td></tr>
<tr><td style="text-align: center">MODE</td><td style="text-align: center">0X06</td><td style="text-align: center">RW</td></tr>
</tbody></table>
</div>
<p><strong>POT</strong></p>
<p>Description: 10 bits potentiometer value.</p>
<div style="display: flex; align-items: flex-start; gap: 20px;">
POT_H 
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">RESERVED</th><th style="text-align: center">POT[9:8]</th></tr></thead><tbody>
</tbody></table>
</div></div>
<div style="display: flex; align-items: flex-start; gap: 20px;">
POT_L 
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">POT[7:0]</th></tr></thead><tbody>
</tbody></table>
</div></div>
<p><strong>LIGHT</strong></p>
<p>Description: 10 bits light value.</p>
<div style="display: flex; align-items: flex-start; gap: 20px;">
LIGHT_H
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">RESERVED</th><th style="text-align: center">LIGHT[9:8]</th></tr></thead><tbody>
</tbody></table>
</div></div>
<div style="display: flex; align-items: flex-start; gap: 20px;">
LIGHT_L
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">LIGHT[7:0]</th></tr></thead><tbody>
</tbody></table>
</div></div>
<p><strong>LEDS</strong></p>
<p>Description: State of the leds. 0 is OFF, 1 is ON.</p>
<div style="display: flex; align-items: flex-start; gap: 20px;">
LEDS_H
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">RESERVED</th><th style="text-align: center">LEDS[8]</th></tr></thead><tbody>
</tbody></table>
</div></div>
<div style="display: flex; align-items: flex-start; gap: 20px;">
LEDS_L
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">LEDS[7:0]</th></tr></thead><tbody>
</tbody></table>
</div></div>
<p>LEDS default value: 0</p>
<p><strong>MODE</strong></p>
<p>Description:</p>
<ul>
<li>POTC: if set, the Attiny will send CONTINUOUS potentiometer data.</li>
<li>LIGHTC: if set, the Attiny will send CONTINUOUS light data.</li>
<li>LEDSC: if set, the Attiny will send CONTINUOUS leds data.</li>
<li>CFREQ: frequency at which CONTINUOUS messages will be sent.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">POTC</th><th style="text-align: center">LIGHTC</th><th style="text-align: center">LEDSC</th><th style="text-align: center">CFREQ[1:0]</th><th style="text-align: center">LEDSMODE[2:0]</th></tr></thead><tbody>
<tr><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"> </td><td style="text-align: center">0x0: 50ms (20Hz)</td><td style="text-align: center">0x0: MANUAL</td></tr>
<tr><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"> </td><td style="text-align: center">0x1: Pot value</td><td style="text-align: center">0x1: 100ms (10Hz)</td></tr>
<tr><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"> </td><td style="text-align: center">0x2: Light value</td><td style="text-align: center">0x2: 200ms (5Hz)</td></tr>
<tr><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"> </td><td style="text-align: center">0x3: Pot speed</td><td style="text-align: center">0x3: 500ms (2Hz)</td></tr>
<tr><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"> </td><td style="text-align: center"></td><td style="text-align: center">0x4: Light speed</td></tr>
</tbody></table>
</div>
<p>Default values:</p>
<ul>
<li>POTC: 0</li>
<li>LIGHTC: 0</li>
<li>LEDSC: 0</li>
<li>CFREQ: 0X01</li>
<li>LEDSMODE: 0x1 (Pot value)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuto-pami"><a class="header" href="#tuto-pami">Tuto PAMI</a></h1>
<h1 id="quest-ce-quun-pami-"><a class="header" href="#quest-ce-quun-pami-">Qu'est ce qu'un PAMI ?</a></h1>
<p><strong>PAMI</strong> est l'acronyme de <strong>Petit Automate Motorisé Indépendant</strong>. Ces robots, plus petits que le robot principal, sont conçus pour être plus accessibles, ce qui en fait un excellent point de départ pour commencer. Leur rôle est crucial pour maximiser les points lors de la Coupe de Robotique, il est donc essentiel d'avoir une bonne compréhension de leur fonctionnement.</p>
<p>Voici les trois PAMIS positionnés au pied de la fusée de l'ESA (ENAC Space Agency), spécialement conçus pour la Coupe de France de Robotique 2024.</p>
<p align="center">
    <img src="bases/tutopami/../../images/tutopami/pami_fusee.jpg"  alt="image" width="600" height="auto">
</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="free-rtos"><a class="header" href="#free-rtos">Free RTOS</a></h1>
<p>
    <img src="bases/tutopami/../../images/tutopami/freertos.png"  alt="image" width="300" height="auto">
</p>
<p>Pour faire fonctionner nos PAMI, on utilise désormais <strong>Free RTOS</strong>. C'est un système d'exploitation en temps réel open source parfaitement adapté pour les microcontrôleurs. Ça tombe bien, c'est exactement ce qu'on utilise à l'intérieur de nos magnifiques PAMIS.</p>
<p>Pour comprendre et utliser freeRTOS, tu auras surement besoin par la suite de la documentation de celui-ci, que tu retrouvera <a href="https://www.freertos.org/">ici</a>.</p>
<p>Je peux également te recommander cette <a href="https://www.youtube.com/playlist?list=PLXyB2ILBXW5FLc7j2hLcX6sAGbmH0JxX8">série de vidéos</a> qui explique le fonctionnement de Free RTOS, mais cela nécessitera quelques bases en programmation pour bien la comprendre.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programmer-un-pami"><a class="header" href="#programmer-un-pami">Programmer un PAMI</a></h1>
<p>Pour commencer à appréhender tous ca, nous avons créer un tutoriel qui te guidera pas-à-pas pour comprendre comment on programme un PAMI.</p>
<h2 id="télécharger-le-tutoriel"><a class="header" href="#télécharger-le-tutoriel">Télécharger le tutoriel</a></h2>
<p>Les tutoriels sont disponibles via Git, il faut donc le télécharger avec le <a href="https://git-scm.com/downloads">lien ici</a></p>
<p>Une fois installéé, lancer le terminal et placer vous dans le répertoire dans lequel vous souhaitez stocker le tuto puis cloner le dépôt PAMIS_2024 en utilisant la commande suivante :</p>
<p><code>git clone https://github.com/ENACRobotique/PAMIS_2024.git</code></p>
<p>ou avec une clé SSH :</p>
<p><code>git clone git@github.com:ENACRobotique/PAMIS_2024.git</code></p>
<br>
Ensuite, dans un terminal, accédez au répertoire PAMIS_2024 et basculez sur la branche tuto_pami avec la commande suivante :
<p><code>git switch TUTO_PAMIS</code></p>
<br>
Suivez ensuite les étapes du tutoriel dans l'ordre indiqué. Si vous rencontrez des difficultés, n'hésitez pas à demander de l'aide, que ce soit au club ou sur le Discord. Tout va bien se passer !
<h1 id="première-partie--déplacement"><a class="header" href="#première-partie--déplacement">Première partie : déplacement</a></h1>
<p>Dans cette première partie, l'objectif va être de faire avancer le robot.<br />
Par exemple, on va essayer de faire en sorte que le robot face des carrés de 10 cm de côté.<br />
Le résultat devrait ressembler à ça :</p>
<p align="center">
    <video id="carre_10cm" width="240" height="auto" loop muted autoplay>
        <source src="../../images/tutopami/carre_10cm.mp4" type="video/mp4">
    </video>
</p>
<script>
    var video = document.getElementById("carre_10cm");
    video.addEventListener('click', function() {
        if(video.paused) {
            video.play();
        } else {
            video.pause();
        }
    });
</script>
<p>Pour réussir à faire ça, le code dispose une fonction déplacement permettant respectivement d'avancer et de tourner :
celle ci se trouve dans le fichier deplacement.c qui se en suivant le chemin suivant PAMI_2024 -&gt; PAMI_SOFT -&gt; src -&gt; deplacement.c</p>
<p>Je vous invite donc à modifier le programme en utilisant les 3 fonctions suivante:
-<code>base_roulante.translate(distance);</code> qui permet de faire avancer le robot avec distance en mm
-<code>base_roulante.rotate(angle);</code> qui permet de faire tourner le robot avec angle en radian
-<code>sleep(durée);</code> qui permet d'attendre avec durée en milliseconde</p>
<p>⭐ Avec tous ces informations, essayez maintenant de faire faire des carrés de 200 cm à votre PAMIS !</p>
<p><br><br></p>
<h1 id="deuxième-partie--évitement"><a class="header" href="#deuxième-partie--évitement">Deuxième partie : évitement</a></h1>
<p>Pour cette partie, on va continuer à modifier notre fonction pour faire en sorte que le robot n'avance plus à la vue d'un obstacle.
Cela ressemblera à ca :
"video a mettre ici"</p>
<p>pour cela, vous aller pouvoir utiliser de nouvelles variables :
-distance_left
-distance_middle
-distance_right
qui renvoie les distances perçues par nos 3 capteurs que vous voyez ci dessous :
"photo du pami a mettre"</p>
<p>⭐ À votre tour d'empecher votre robot de se cracher dans les murs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commencer-un-robot-pour-la-coupe"><a class="header" href="#commencer-un-robot-pour-la-coupe">Commencer un robot pour la coupe</a></h1>
<p>Avant de continuer sur cette section vous devriez avoir fait tout les tutoriels ou traité de toutes les thématiques liées.</p>
<p>Les sections suivantes contiennent le fruit de notre travail commun comportant nos réflexions personnelles ou des liens vers des tutoriels utilisés.</p>
<p>Pour faire un robot il y a plusieurs étapes liées par des étages de compléxité qui peuvent croître très vite, surtout quand on ne l'a jamais fait. Si vous ne maitrisez pas la section précédente, vous vous rajoutez une couche de complexité qui vous empêchera d'avancer.</p>
<h1 id="todo"><a class="header" href="#todo">TODO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base-holonome"><a class="header" href="#base-holonome">Base holonome</a></h1>
<p>Considérons une roue, les calculs seront identiques pour les autres roues.</p>
<h2 id="rotation"><a class="header" href="#rotation">Rotation</a></h2>
<p>Commençons par le plus simple : la rotation du robot sur lui-même. Le robot doit simplement faire tourner ses roues à la même vitesse.</p>
<p>Les roues sont placées à égale distance \(R\) du centre du robot, leurs axes passant par le centre du robot.</p>
<p>Si le robot tourne sur lui-même à une vitesse angulaire \(ꞷ\), la vitesse d'une roue sera donc \(Vtr = R.ꞷ\).</p>
<p><img src="to_robot/base_roulante/../images/holonome_vitesse_angulaire.png" alt="" title="Rotation" /></p>
<h2 id="translation"><a class="header" href="#translation">Translation</a></h2>
<p>La roue est placée à un angle \(β\) par rapport au repère du robot. Cet angle est fixé par la construction du robot.</p>
<p>Supposons que le robot se déplace en translation pure à une vitesse \(V\) qui forme un angle \(α\) avec le repère du robot.</p>
<p>La vitesse tangentielle de la roue sera donc de \(Vtr = V.sin(α-β)\).</p>
<p>La roue étant en translation libre sur l'axe radial, la vitesse radiale peut être ignorée.</p>
<p><img src="to_robot/base_roulante/../images/holonome_vitesse.png" alt="" title="Translation" /></p>
<h2 id="composition-des-vitesses-et-décomposition-selon-les-axes-du-robot"><a class="header" href="#composition-des-vitesses-et-décomposition-selon-les-axes-du-robot">Composition des vitesses, et décomposition selon les axes du robot</a></h2>
<p>Par la composition des vitesses, la vitesse tangentielle totale d'une roue est : \(Vtr = V.sin(α-β) + R.ꞷ\)</p>
<p>On connait l'identité trigonométrique : \(sin(α-β) = sin(α).cos(β) - cos(α).sin(β)\)</p>
<p>On peut donc écrire</p>
<p>\[Vtr = V.sin(α).cos(β) - V.cos(α).sin(β) + R.ꞷ\]</p>
<p>Si on décompose la vitesse \(V\) du robot selon ses axes, on a :</p>
<ul>
<li>\(Vx = V.cos(α)\)</li>
<li>\(Vy = V.sin(α)\)</li>
</ul>
<p>On en déduit donc :</p>
<p>\[Vtr = Vy.cos(β) - Vx.sin(β) + R.ꞷ\]</p>
<h2 id="forme-matricielle"><a class="header" href="#forme-matricielle">Forme matricielle</a></h2>
<p>Pour 3 roues placées respectivement aux angles \(β1\), \(β2\) et \(β3\), on aura alors :</p>
<p>\[ \begin{pmatrix}v1\\v2\\v3\end{pmatrix}=\begin{pmatrix}-sin(β1) &amp; cos(β1) &amp; R\\-sin(β2) &amp; cos(β2) &amp; R\\-sin(β3) &amp; cos(β3) &amp; R\end{pmatrix}\times\begin{pmatrix}Vx\\Vy\\ꞷ\end{pmatrix} \]</p>
<h1 id="cinématique-inverse"><a class="header" href="#cinématique-inverse">Cinématique inverse</a></h1>
<p>On a calculé les commandes à donner aux moteurs pour avoir le déplacement désiré. On voudrait maintenant déduire les déplacements du robot des déplacements de chaque moteur.</p>
<p>On avait : \(m=D.V\)</p>
<p>La matrice pseudo-inverse de Moore-Penrose \(D^+\) permet de résoudre ce problème. On a alors : \(V=D^+.m\)</p>
<p>Elle peut être calculée avec numpy avec la fonction <code>numpy.linalg.pinv</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carte-électronique-pour-la-base-roulante"><a class="header" href="#carte-électronique-pour-la-base-roulante">Carte électronique pour la base roulante</a></h1>
<p>La base roulante ce n'est pas juste des moteurs et des roues. Il faut pouvoir les piloter. Pour cela il y a deux solutions possibles, soit utiliser des composants dédiés du commerce, soit faire ses propres contrôleurs. Sachant qu'au final il y aura forcément une partie à faire soi-même pour l'intégrer à l'ensemble de l'architecture.</p>
<p>L'étage éléctrique de votre base roulante doit comporter à minima :</p>
<ul>
<li>Des drivers moteurs</li>
<li>Des encodeurs (ou de quoi mesurer le déplacement des roues)</li>
<li>Une alimentation</li>
<li>Des étages de transformation de puissance</li>
<li>Un microcontrôleur ( à programmer )</li>
<li>Des connectiques pour la communication (USB, UART)</li>
</ul>
<p>Exemples :</p>
<ul>
<li>
<p>Driver moteur utilisé en 2023 : <a href="https://www.elektor.fr/cytron-10amp-5-30-v-dc-motor-driver">MD10C</a></p>
</li>
<li>
<p>Transformation de puissance : <a href="https://github.com/ENACRobotique/elec/tree/master/2023/CarteAlimV2.5">carte d'alim 2023</a></p>
</li>
</ul>
<p>Le microcontrôleur gère donc l'asservissement et les consignes (de vitesse) moteurs. Il communique aussi ( si nécéssaire ) avec le haut niveau pour renvoyer l'état de position et récupérer les consignes (de position, ou de vitesse).</p>
<p>Pour 2023 on a utilisé des MD10C pilotés par une stm32 : <a href="https://github.com/ENACRobotique/elec/tree/master/2023/CartePrincipaleRobot">carte de contrôle 2023</a> mais cette carte s'ocuppait de tout les composantes bas niveaux.</p>
<p>Pour 2024 on a décidé de faire une carte dédiée spécifiquement à la base holonome : <a href="https://github.com/ENACRobotique/Carte_Base_roulante_2024">Carte Base 2024</a>. Nous détaillerons donc un peu plus sa conception.</p>
<h2 id="quelques-liens-utiles-sur-les-notions"><a class="header" href="#quelques-liens-utiles-sur-les-notions">Quelques liens utiles sur les notions</a></h2>
<p>Youtube: <a href="https://www.youtube.com/watch?v=-PCuDnpgiew&amp;t=442s">The Ultimate Guide to using Motors in Robotics</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="carte-base-2024"><a class="header" href="#carte-base-2024">Carte Base 2024</a></h1>
<p>Cette section vise à montrer et expliquer la conception de la carte pour simplement la comprendre. Elle sert aussi de support pour guider quelqu'un dans la conception d'une carte similaire.</p>
<p>Petit visuel sur la carte:</p>
<img src="to_robot/base_roulante/../../images/carte_base_2024_annotation.png" alt="image" width="350" height="auto">
<h2 id="utilisation-1"><a class="header" href="#utilisation-1">Utilisation</a></h2>
<h2 id="conception"><a class="header" href="#conception">Conception</a></h2>
<p>Bien évidemment il faut d'abord commencer par la schématique fonctionelle de nos composants. En les choisissant soigneusement et en vérifiant toutes leurs dépendances.</p>
<p>Ensuite on procède à un placement préliminaire des composants en essayant d'imaginer les routages qui seront nécéssaires. On essaie de faire le moins de croisement possible et si nécéssaire on modifie l'affectation des pins de la schématique.</p>
<p>Enfin on s'occupe du routage. On fait attention à l'utilisation des grilles et on travaille en système métrique.</p>
<h4 id="microcontrolleur-µc"><a class="header" href="#microcontrolleur-µc">Microcontrolleur (µC):</a></h4>
<p>Sur les cartes de développement on précise génréalement dans les datasheets sur quelle pin se trouvent les fonctions et où elles se situent sur la carte. Ici, c'est à nous de les placer. En partant du microcontolleur et en les routant ailleurs sur la carte à notre bon vouloir.</p>
<p>Un outil confortable pour cela est cube MX. Il permet de visualiser (et configurer mais on ne le fera pas ici) la puce ou même les cartes de dévelopement. Vous trouverez ci-dessous la configuration choisie des broches du µC. Elle à été faite itérativement. Tout d'abord chercher les broches qui ont les fonctions qui nous intéressent et essayer de les mettre du coté où elles seront routées. Au moment de les placer physiquement sur la carte on peut itérativement chercher la meilleur configuration.</p>
<img src="to_robot/base_roulante/../../images/cube_mx_stm.png" alt="image" width="400" height="auto">
<p>Comme décrit dans la section 5.1.6 de la datasheet du g484 il faut penser à ajouter aux alimentations des <a href="to_robot/base_roulante/../../elec/notions.html">capacités de découplage</a> pour permettre son bon fonctionnement.</p>
<img src="to_robot/base_roulante/../../images/g484-5.1.6.png" alt="image" width="350" height="auto">
<h4 id="mesure-du-niveau-de-batterie"><a class="header" href="#mesure-du-niveau-de-batterie">Mesure du niveau de batterie</a></h4>
<p>Il suffit d'utiliser un pont diviseur de tension où le pont est connecté directement à une broche du microcontrôleur. En pratique la batterie étant très durable on ne s'en est pas beaucoup servi. ( Mais on s'en est beaucoup servi sur les PAMI !)</p>
<img src="to_robot/base_roulante/../../images/meas_bat.png" alt="image" width="200" height="auto">
<h4 id="protection-de-polarité-inversé"><a class="header" href="#protection-de-polarité-inversé">Protection de polarité inversé</a></h4>
<img src="to_robot/base_roulante/../../images/protection_zener.png" alt="image" width="200" height="auto">
<ul>
<li>
<p>Gestion de puissance</p>
</li>
<li>
<p>Driver</p>
</li>
<li>
<p>Connectiques</p>
</li>
<li>
<p>Imu</p>
</li>
</ul>
<h2 id="problèmes-rencontrés"><a class="header" href="#problèmes-rencontrés">Problèmes rencontrés</a></h2>
<p>Pour une raison encore non comprises, il arrive que la carte subisses de chutes de tension. Par conséquent le microcontrôleur redémarre et cela fait complètement planter le robot en condition de match. La solution de contournement trouvé en attendant est de brancher l'USB pour avoir un maintien de la tension du microcontrôleur afin qu'il supporte ces chutes de tension.</p>
<h2 id="composants-"><a class="header" href="#composants-">Composants :</a></h2>
<p>La plupart sont disponibles sur <a href="https://fr.rs-online.com/web/">RS</a></p>
<ul>
<li><a href="to_robot/base_roulante/../../datasheets/stm32g484re-1.pdf">Microcontrôleur STM32G484RET</a></li>
<li><a href="to_robot/base_roulante/../../datasheets/Infineon-IFX9201SG-DS-v01_01-EN.pdf">Drivers Moteur IFX9201SG</a></li>
<li><a href="to_robot/base_roulante/../../datasheets/lsm6dsl.pdf">IMU LSM6DSL</a></li>
<li>Régulateur 5V- 3.3V : LM3940IMP-3.3</li>
<li><a href="to_robot/base_roulante/../../datasheets/R-78E-1.0.pdf">Régulateur R-78E5.0-1.0</a></li>
<li><a href="to_robot/base_roulante/../../datasheets/Infineon-IRF7404-DataSheet-v01_01-EN.pdf">Transistor MOSFET IRF7404</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notions-pour-la-conception-de-circuit-éléc"><a class="header" href="#notions-pour-la-conception-de-circuit-éléc">Notions pour la conception de circuit éléc</a></h1>
<h2 id="les-capacités-de-découplage"><a class="header" href="#les-capacités-de-découplage">Les capacités de découplage</a></h2>
<p>Un condensateur de découplage est un condensateur destiné à réduire le couplage entre un signal et une alimentation. Le condensateur relie le canal d'alimentation à la masse pour abaisser son impédance dans la bande passante du signal.</p>
<p>On n'a pas besoin d'une grande précision sur la valeur du composant. Celle-ci dépend de l'intensité qui traverse le canal et de la fréquence du signal.</p>
<p>Sans ce découplage, les pointes de courant demandées provoquent des <strong>chutes de tension</strong> très brèves, qui gênent le fonctionnement sain des composants.</p>
<p>L'énergie emmagasinée localement dans les condensateurs de découplage suffit à compenser les chutes.</p>
<p>Généralement, ce type de condensateur n'est pas seul. Ils sont au moins deux, voire trois.</p>
<ul>
<li>un chimique pour des pointes à faible fréquence. (exemple 10 µF)</li>
<li>un "film" pour des fréquences moyennes. (exemple 0,1 µF)</li>
<li>un céramique pour les hautes fréquences. (exemple 100 pF)</li>
</ul>
<p>Les valeurs ne sont pas critiques. La qualité doit être bonne, et surtout, les connexions <strong>hyper courtes</strong>.</p>
<p>Quelques liens expliquant plus en profondeur:</p>
<ul>
<li><a href="https://www.multipower.fr/-ressources/blog-2/condensateurs-de-decouplage/">Electronique 71</a></li>
<li><a href="http://electronique71.com/theories-condensateur-de-decouplage/">Multipower</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asservissement"><a class="header" href="#asservissement">Asservissement</a></h1>
<p>Le principe de l'asservissement est de permettre à un moteur d'atteindre un objectif donné par "l'utilisateur" (par exemple, atteindre telle position ou tenir telle vitesse, avec un certain degré de précision et de "rapidité" )</p>
<h2 id="la-théorie"><a class="header" href="#la-théorie">La théorie</a></h2>
<p>La bible sur les <strong>principes généraux</strong> : <a href="https://www.pm-robotix.eu/2022/02/02/asservissement-et-pilotage-de-robot-autonome/">PM-robotix</a></p>
<p><a href="http://www.rcva.fr/wp-content/uploads/2016/12/devoir_de_vacances.pdf">RCVA</a></p>
<h2 id="limplémentation"><a class="header" href="#limplémentation">L'implémentation</a></h2>
<p>Pour réaliser un asserv en vitesse, il faut :</p>
<ol>
<li>Fournir des consignes vitesses au robot, par exemple en envoyant du PWM grâce aux drivers moteurs types MD10C/D13S (<a href="https://github.com/ENACRobotique/2022_Robot_A/blob/main/src/motor.cpp#L82">Exemple du code de 2022</a>)</li>
<li>Lire les données des <a href="https://www.generationrobots.com/blog/wp-content/uploads/2014/01/Encodeur-FR.png">encodeurs rotatifs</a>, pour connaître la vitesse des moteurs <a href="https://github.com/ENACRobotique/2022_Robot_A/blob/main/src/odom.cpp">Exemple en 2022, lecture software</a>. (<a href="https://www.generationrobots.com/blog/fr/encodeurs-robotique-mobile/">plus d'info sur les encodeurs</a>)</li>
<li>Prévoir une "interface" avec l'ordinateur (en serial par exemple), c'est-à-dire pouvoir envoyer sur le port serial les coefficients du PID et recevoir les données de l'encodeur, pour pouvoir tracer des graphes/enrengistrer les données sur l'ordinateur</li>
<li>Régler l'asservissement grâce à des courbes, en envoyant des consignes depuis le PC et en voyant le résultat</li>
<li>Méthode de réglage :  <a href="https://assos.utc.fr/utcoupe/wiki/doku.php?id=informatique:asservissement">une idée de méthode de l'UTC</a></li>
</ol>
<h2 id="pour-aller-plus-loin-pour-améliorer-lasserv"><a class="header" href="#pour-aller-plus-loin-pour-améliorer-lasserv">Pour aller plus loin pour améliorer l'asserv</a></h2>
<p>Pour l'instant, on s'arretait là, mais il peut être intéressant de tester un asserv en position directement (qui envoie des consignes vers le système qui asservit en vitesse), ou d'implémenter les solutions vues en dessous.</p>
<p><strong>TODO</strong> Différence lecture hardware/software des encodeurs</p>
<p>Réglage plus fin du <strong>PID</strong> :
<a href="https://www.pm-robotix.eu/2022/01/19/ameliorer-vos-regulateurs-pid/">PM-robotix</a></p>
<p><a href="https://www.ni.com/fr-fr/innovations/white-papers/08/improving-pid-controller-performance.html">improving PID - ni.com</a></p>
<p>Réglage plus fin du coeff des roues :
<a href="https://github.com/VRAC-team/la-maxi-liste-ressources-eurobot/blob/master/odometrie/RCVA-Conseils_theoriques_pour_Eurobot.pdf">RCVA</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raspberry-pi"><a class="header" href="#raspberry-pi">Raspberry Pi</a></h1>
<p>La Raspberry Pi est un petit ordinateur monocarte que l'on va embarquer dans certains de nos robots.</p>
<h2 id="graver-limage"><a class="header" href="#graver-limage">Graver l'image</a></h2>
<p>Pour commencer, il faut télécharger <a href="to_robot/haut_niveau/(https://www.raspberrypi.org/downloads/raspbian/)">une version récente de Raspbian</a>, la distribution officielle pour la Raspberry Pi. Sachant qu'on va l'utiliser sans jamains brancher d'écran, il vaut mieux prendre la version Lite, bien plus légère.</p>
<p>Il va falloir graver cette image sur une carte SD. Pour cela, utilisez <a href="https://www.balena.io/etcher/">Etcher</a>, qui est très simple d'utilisation et marche très bien.</p>
<p>Une fois l'image gravée, ne vous précipitez pas. Nous allons modifier quelques fichiers de la carte SD afin de faciliter la configuration.</p>
<h2 id="pré-configuration"><a class="header" href="#pré-configuration">Pré-configuration</a></h2>
<p><strong>WiFi</strong> : On va faire en sorte que la raspi se connecte directement au réseau WiFi du club.</p>
<p>Éditez le fichier <code>&lt;carte SD Raspi&gt;/etc/wpa_supplicant/wpa_supplicant.conf</code> (les droits d'admin seront sans doute nécessaires), et ajoutez le texte suivant (en remplaçant <em>lemotdepasse</em> par le mot de passe, bien entendu) :</p>
<pre><code class="language-plain-text">network={
    ssid="robot"
    psk="lemotdepasse"
}
</code></pre>
<p><strong>SSH</strong> : Pour activer le SSH sans brancher un écran et un clavier, créer un fichier <code>ssh</code> dans la partition <em>boot</em> (celle formatée en FAT). Les identifiants par défauts sont :</p>
<p>utilisateur: pi<br />
hostname: raspberrypi<br />
password : raspberry</p>
<p>Il est mainteant temps de démarrer la Raspberry Pi !</p>
<h2 id="configuration-la-suite"><a class="header" href="#configuration-la-suite">Configuration, la suite</a></h2>
<p>On va donc démarrer la Raspberry Pi en l'alimentant soit par l'USB (solution la plus simple), soit par les broches GND et 5V (seulement si vous savez ce que vous faites !).
Elle devrait automatiquement se connecter au réseau WiFi. Vous pouvez tenter un <code>ping raspberrypi</code>, ou chercher son adresse sur l'interface du routeur.<br />
Quand vous avez trouver, s'y connecter en SSH : <code>ssh pi@raspberrypi</code>, ou <code>ssh pi@192.168.XXX.xxx</code>.</p>
<p><code>sudo raspi-config</code> : changer le hostname, rebooter. (autre choses ?)</p>
<p><strong>UART</strong> : On va certainement utiliser l'UART de la raspi. Sur la Raspberry Pi 3 (et peut être aussi sur d'autres modèles), il faut modifier la configuration pour pouvoir l'utiliser (<a href="https://www.framboise314.fr/le-port-serie-du-raspberry-pi-3-pas-simple/">source</a>).</p>
<p>Ajoutez cette ligne au ficher <code>/boot/config.txt</code> : <code>dtoverlay=pi3-disable-bt</code>.</p>
<p>Dans le fichier <code>/boot/cmdline.txt</code>, supprimez <code>console=serial0,115200</code>.</p>
<p>Quand la raspberrypi sera démarrée, vous prendrez soin de vérifier que <code>serial0 -&gt; ttyAMA0</code> et <code>serial1 -&gt; ttyS0</code> en faisant un <code>ls -l /dev/serial*</code>.</p>
<p>Il est peut-être nécessaire d'aller activer l'UART dans <code>sudo raspi-config</code>. À vérifier.</p>
<p>Pour vérifier si ça marche : connectez RX et TX ensemble par un câble de breadboard, ouvez minicom <code>minicom -D /dev/ttyAMA0</code>, et tapez des trucs. Si les caractères s'affichent c'est que ça marche. Si vous débranchez le fil ça ne devrait pas marcher. Pour quitter minicom : <code>CTRL+A, q, ENTER</code></p>
<p><strong>Quelques packets à installer</strong> :</p>
<ul>
<li><code>git</code> : gestion de version,</li>
<li><code>python3-pip</code> : gestionnaire de modules python3,</li>
<li><code>minicom</code> : moniteur port série,</li>
<li><code>vim</code> : coloration syntaxique et clavier pour humain, pour l'éditeur de texte <em>vi</em>. Pour <a href="http://www.commitstrip.com/fr/2017/05/29/trapped/">sortir</a> : échap, puis <code>:q</code>, ou <code>:q!</code> si ça veut pas.</li>
</ul>
<p><code>sudo apt install git python3-pip minicom vim</code></p>
<p>Quelques modules python que l'on va souvent utiliser :</p>
<ul>
<li><code>pyserial</code> : pour uiliser un port série,</li>
<li><code>ivy-python</code> : pour communiquer avec <a href="http://www.eei.cena.fr/products/ivy/">Ivy</a>,</li>
<li><code>bitstring</code> : pour convertir des nombres en bytes et inversement.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comment-interfacer-le-robot-"><a class="header" href="#comment-interfacer-le-robot-">Comment interfacer le robot ?</a></h1>
<ul>
<li><a href="https://github.com/KirrimK/RoboKontrol">Robokontrol</a>
<ul>
<li>Afficher la position du robot sur la carte</li>
<li>Ctrl actionneurs</li>
<li>Bouger robot (pos,vit)</li>
</ul>
</li>
<li>eCAL (monitor, recorder, player)
<ul>
<li>Rejouer les données</li>
<li>Afficher les msg</li>
<li>Graphe en fc du tps</li>
</ul>
</li>
<li>robot_sim_ecal (en cours de création)
<ul>
<li>Bouton+slider dynamique(scripter, avec délai)</li>
<li>Afficher LIDAR</li>
<li>Afficher état du robot</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-machine"><a class="header" href="#state-machine">State machine</a></h1>
<ul>
<li><a href="https://github.com/KirrimK/graph2strat/">g2S</a></li>
</ul>
<h1 id="ia"><a class="header" href="#ia">IA</a></h1>
<ul>
<li>
<p>Concept du <a href="https://www.youtube.com/watch?v=nEnNtiumgII">Goal Oriented Action Planning</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=PaOLBOuyswI">AI of F.E.A .R</a></p>
</li>
<li>
<p><a href="https://github.com/cvra/goap-cpp">Un exemple intéressant</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lancement-dobjets-exemples-rusty---2018"><a class="header" href="#lancement-dobjets-exemples-rusty---2018">Lancement d'objets (Exemples rusty - 2018)</a></h1>
<h2 id="inventaire-des-systèmes-existants-rusty-ducks-2018"><a class="header" href="#inventaire-des-systèmes-existants-rusty-ducks-2018">Inventaire des systèmes existants (Rusty ducks 2018)</a></h2>
<p>On a déjà lancé des balles avec un <strong>moteur</strong> qui <strong>entraîne un galet</strong>, ça marche très bien.</p>
<p>On n'asservissait pas le moteur, donc on n'était pas super précis, mais des équipes asservissaient le moteur, et ils étaient assez précis.
D'autres équipes utilisaient des petits solénoïdes avec une tige qui sort de quelques cm quand c'est alimenté, ça à l'air de bien marcher, mais on n'a jamais trouvé les bon trucs (on n'a peut être pas beaucoup chercher).</p>
<p>Et d'autres équipes font avec des <strong>turbines</strong>, on n'a jamais fait non plus, principalement car on n'en n'a pas au club.</p>
<p><a href="https://www.youtube.com/watch?v=qMOzlV9TB9M&amp;t=3564s">Système en action chez les rusty</a></p>
<h2 id="axes-damélioration"><a class="header" href="#axes-damélioration">Axes d'amélioration</a></h2>
<p>Avec des moteurs <strong>brushless</strong>, on peut obtenir des meilleures performances car un brushless ça se rapproche plus d'un moteur pas à pas que d'un moteur DC. Donc il est contrôlé assez précisément en vitesse, et ça ne va pas changer suivant la tension de la batterie (sauf si tu arrive à la limite max de rotation). Mais pour compenser le problème du moteur dépendant de la tension de batterie, on peut mettre un régulateur de tension entre les deux.</p>
<p>Mais il n'y a pas que ça : quand tu envoies la balle, le moteur ralentie. Donc soit tu as assez de puissance et d'inertie pour que le moteur ait retrouvé sa vitesse initiale avant que la prochaine balle n'arrive, soit il faut envoyer les balles les unes après les autres, doucement. C'est ce qu'on faisait.</p>
<p><a href="https://youtu.be/qMOzlV9TB9M?t=9950">Système en action pendant la finale chez robotech</a></p>
<p><a href="https://www.youtube.com/watch?v=AtQNcGx7NgY">Présentation robotech du système</a></p>
<p><a href="https://www.planete-sciences.org/forums/viewtopic.php?f=5&amp;t=18380">Explication robotechs de leur robot 2018</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="petits-tutos"><a class="header" href="#petits-tutos">Petits Tutos</a></h1>
<p>Il y aura dans cette section des petits tutos sur des sujet divers et variés, qui ne méritent pas un chapitre entier.</p>
<h2 id="ressources-en-ligne"><a class="header" href="#ressources-en-ligne">Ressources en ligne</a></h2>
<h3 id="en-général"><a class="header" href="#en-général">En général</a></h3>
<p>De nombreuses ressources en ligne existent déjà, parmi lesquelles on peut noter :</p>
<ul>
<li><a href="https://www.eurobot.org/wiki/fr/home"><strong>WIki Eurobot</strong></a> wiki officiel pour la coupe de france de robotique, encore assez peu complet</li>
<li><a href="https://github.com/VRAC-team/la-maxi-liste-ressources-eurobot"><strong>VRAC, Une compilation de tutoriels</strong></a> par "section" (moteurs, odométrie, ...) ciblant les spécificités de la coupe de france</li>
<li><a href="https://gm0.org/en/latest/index.html"><strong>Game Manual, ANGLAIS</strong>,</a> un gros "wiki" pour la compétition de robots FIRST (USA), assez similaire à la coupe de France mais en plus bourrin
<ul>
<li>En particulier, les sections :</li>
<li><a href="https://gm0.org/en/latest/docs/design-skills/index.html">Design Skills</a> pour la mécanique</li>
<li><a href="https://gm0.org/en/latest/docs/hardware-components/tips-and-tricks.html">Hardware components, Tips and trick</a> pour la mécanique</li>
<li>Common Mechanisms, pour de l'inspiration</li>
<li>Pour les roues folles/codeuses holonomes, <a href="https://gm0.org/en/latest/docs/common-mechanisms/dead-wheels.html">Dead Wheels</a></li>
<li>Electronics and components pour certaines choses</li>
<li><a href="https://gm0.org/en/latest/docs/software/concepts/index.html">Programming Concept</a> pour la partie code (le reste est relativement spécifique au Java donc pas trop utilisable)</li>
</ul>
</li>
</ul>
<h3 id="pour-le-code"><a class="header" href="#pour-le-code">Pour le code</a></h3>
<ul>
<li><a href="https://learnroadrunner.com/">Road Runner</a>, une librairie de code en Java pour <strong>programmer des robots holonomes</strong>, qui peut servir d'inspiration</li>
<li>Des tutoriels sur l'<strong>asserv</strong> sont disponibles dans le <a href="petits_tutos/../rex/asserv.html">REX Asserv</a></li>
<li>Des conseils sur les déplacements et autres des <a href="https://www.pm-robotix.eu/category/alaune/">pm-robotix</a></li>
</ul>
<h2 id="sommaire-de-la-section"><a class="header" href="#sommaire-de-la-section">Sommaire de la section</a></h2>
<p>Commençons par apprendre comment <a href="petits_tutos/raspberry_pi.html">mettre en oeuvre une raspberry pi !</a></p>
<p>Problème lors du branchement d'une carte pendant quelques secondes : <code>/dev/tty_xxx: Périphérique ou ressource occupé</code>. <a href="petits_tutos/peripherique_occupe.html">Résolvez le problème !</a>
| Tutoriel                                                          | Méca | Elec | Info - C | Info - Python |
| <a href="petits_tutos/../petits_tutos/microcontrollers.html">Les différents microcontrôleurs</a>  |      | X    |   X     |           |
| <a href="petits_tutos/../petits_tutos/simulator.html">Le simulateur et les IHM (2022-2023)</a>  |      |    |   X     |    X     |</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="se-débarasser-du-périphérique-occupé-lors-du-branchement-dun-device"><a class="header" href="#se-débarasser-du-périphérique-occupé-lors-du-branchement-dun-device">Se débarasser du "périphérique occupé" lors du branchement d'un device</a></h1>
<p>Le responsable de ce bazar, c'est ModemManager, un service qui permet de contrôler les périphériques mobile 2G/3G/4G. <a href="https://www.freedesktop.org/wiki/Software/ModemManager/">Plus d'infos</a>.</p>
<p>On va faire en sorte qu'il blacklist tout les péiphériques <strong>tty*</strong>.</p>
<p>D'abord on exécute la commande <code>sudo systemctl status ModemManager</code>.<br />
Voilà un exemple de sortie :</p>
<pre><code class="language-plain">● ModemManager.service - Modem Manager
   Loaded: loaded (/lib/systemd/system/ModemManager.service; enabled; vendor preset: enabled)
   Active: active (running) since Fri 2019-11-15 15:42:25 CET; 13min ago
 Main PID: 6815 (ModemManager)
    Tasks: 3 (limit: 4915)
   CGroup: /system.slice/ModemManager.service
           └─6815 /usr/sbin/ModemManager --filter-policy=strict

</code></pre>
<p>Ensuite on va éditer le fichier indiqué à la ligne <em>Loaded</em> :</p>
<p><code>sudo vi /lib/systemd/system/ModemManager.service</code></p>
<p>A la section <em>[Service]</em> du fichier, rajoutez une ligne :</p>
<pre><code class="language-plain">[Service]
...
Environment="MM_FILTER_RULE_TTY_ACM_INTERFACE=0"
</code></pre>
<p>Enfin il faut recharger la configuration de <em>systemctl</em> et redémarrer le ModemManager:</p>
<pre><code class="language-plain">sudo systemctl daemon-reload
sudo systemctl restart ModemManager
</code></pre>
<p>Source : <a href="https://askubuntu.com/a/1119498">https://askubuntu.com/a/1119498</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
